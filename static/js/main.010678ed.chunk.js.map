{"version":3,"sources":["core/IOStream.ts","core/Interpreter.ts","core/ImmutableList.ts","core/Runner.ts","core/utils.ts","hooks/useBrainfuck.ts","components/Console.tsx","components/ControlPanel.tsx","components/Editor.tsx","components/Visualization.tsx","components/App.tsx","index.tsx"],"names":["copyStream","stream","buffer","slice","readBuffer","initializeIOStream","size","pointer","readPointer","pendingSize","ioReducer","action","type","newStream","length","read","data","concat","Math","max","write","index","seek","instructionSet","Set","copyState","state","readMemory","memory","query","dataPointer","writeMemory","update","isEnded","programCounter","program","isStarted","blocked","parse","output","startsWith","count","Error","s","has","push","brainfuckReducer","newState","instruction","fetchInstruction","overridePc","skipping","stdin","undefined","stdout","jmpStack","pop","next","writeToStdin","buildTree","start","end","mid","floor","left","right","key","value","queryTree","node","updateTree","newNode","Object","assign","sliceTree","result","List","root","fromArray","this","array","createList","MAX_PROGRAM_CYCLES","run","cycles","console","error","finalState","numCycles","ended","ASCIIsToString","n","String","fromCharCode","stringToASCIIs","Array","from","map","c","charCodeAt","setup","parsed","fill","Console","programState","dispatch","useState","inputText","setInputText","ioBuffers","useMemo","input","className","onKeyUp","e","onChange","target","ControlPanel","onClick","disabled","Editor","code","setCode","enabled","language","placeholder","val","padding","style","fontSize","Visualization","pc","App","initialProgram","setProgram","parsedProgram","setProgramState","useCallback","useBrainfuck","brainfuck","editorEnabled","useEffect","id","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.010678ed.chunk.js","sourcesContent":["import { ReducerAction } from \"../types\";\n\nexport type IOAction =\n  | ReducerAction<\"read\" | \"seek\", number>\n  | ReducerAction<\"write\", number | number[]>;\nexport type IOStream = {\n  buffer: number[];\n  size: number;\n  pointer: number;\n  // The buffer for the last read\n  readPointer: number;\n  readBuffer: number[];\n  pendingSize: number;\n};\n\nexport type ReadOutput = [stream: IOStream, data: number];\n\nconst copyStream = (stream: IOStream) => ({\n  ...stream,\n  buffer: stream.buffer.slice(0),\n  readBuffer: stream.readBuffer.slice(0),\n});\n\n/**\n * When the stream is blocked (pendingSize > 0), no data will be read into the buffer\n */\nexport const read = (stream: IOStream, size: number): IOStream => {\n  let newStream = copyStream(stream);\n  if (newStream.pendingSize > 0 || newStream.buffer.length <= newStream.readPointer) {\n    newStream.pendingSize += size;\n    return newStream;\n  }\n\n  // Read `size` of bytes from the buffer\n  newStream.readBuffer = newStream.buffer.slice(\n    newStream.readPointer,\n    newStream.readPointer + size\n  );\n\n  newStream.readPointer = newStream.readPointer + newStream.readBuffer.length;\n  if (newStream.readBuffer.length < size) {\n    // We haven't read enough bytes, expect more inputs\n    newStream.pendingSize += size - newStream.readBuffer.length;\n  }\n\n  return newStream;\n};\n\nexport const write = (stream: IOStream, data: number | number[]): IOStream => {\n  if (typeof data == \"number\") data = [data];\n\n  let newStream = copyStream(stream);\n  newStream.buffer = newStream.buffer.slice(0, newStream.pointer).concat(data);\n  newStream.pointer += data.length;\n\n  if (newStream.pendingSize > 0) {\n    // Prevent pendingSize from underflowing\n    newStream.pendingSize = Math.max(newStream.pendingSize - data.length, 0);\n  }\n\n  return newStream;\n};\n\nconst seek = (stream: IOStream, index: number): IOStream => {\n  let newStream = copyStream(stream);\n  newStream.pointer = index;\n  newStream.readPointer = index;\n  return newStream;\n};\n\nexport const initializeIOStream = (size: number): IOStream => ({\n  buffer: [],\n  size: size,\n  pointer: 0,\n  readPointer: 0,\n  readBuffer: [],\n  pendingSize: 0,\n});\n\nexport const ioReducer = (stream: IOStream, action: IOAction): IOStream => {\n  switch (action.type) {\n    case \"read\":\n      return read(stream, action.data);\n    case \"write\":\n      return write(stream, action.data);\n    case \"seek\":\n      return seek(stream, action.data);\n  }\n};\n","import { ReducerAction } from \"../types\";\nimport { ioReducer, IOStream } from \"./IOStream\";\nimport { List } from \"./ImmutableList\";\n\nexport type BrainfuckCoreAction = ReducerAction<\"next\"> | ReducerAction<\"write\", number[]>;\nconst instructionSet = new Set([\"<\", \">\", \",\", \".\", \"[\", \"]\", \"+\", \"-\"]);\nexport type Instruction = \"<\" | \">\" | \",\" | \".\" | \"[\" | \"]\" | \"+\" | \"-\";\n\nexport type ProgramState = {\n  programCounter: number;\n  dataPointer: number;\n  memory: List<number>;\n  jmpStack: number[];\n  program: Instruction[];\n\n  skipping: boolean;\n  blocked: boolean;\n\n  stdin: IOStream;\n  stdout: IOStream;\n};\n\nconst copyState = (state: ProgramState): ProgramState => ({\n  ...state,\n});\n\nconst readMemory = (state: ProgramState) => state.memory.query(state.dataPointer);\nconst writeMemory = (state: ProgramState, data: number) =>\n  (state.memory = state.memory.update(state.dataPointer, data));\nconst fetchInstruction = (state: ProgramState): Instruction => state.program[state.programCounter];\n\nexport const isEnded = (state: ProgramState) => state.programCounter === state.program.length;\nexport const isStarted = (state: ProgramState) => state.programCounter > 0 || state.blocked;\n\n/**\n * Parse out the initial loop and ignore non-instruction characters\n */\nexport const parse = (program: string): Instruction[] => {\n  let output: any = [];\n  if (program.startsWith(\"[\")) {\n    let count = 1,\n      index = 1;\n    while (count > 0) {\n      if (program[index] === \"[\") {\n        count++;\n      }\n      if (program[index] === \"]\") {\n        count--;\n      }\n      if (index > 30000) {\n        throw new Error(\"Unbalanced brackets\");\n      }\n      index++;\n    }\n    program = program.slice(index + 1);\n  }\n\n  for (let s of program) {\n    if (instructionSet.has(s)) {\n      output.push(s);\n    }\n  }\n  return output;\n};\n\nconst next = (state: ProgramState): ProgramState => {\n  if (isEnded(state)) return state;\n\n  let newState = copyState(state);\n\n  const instruction = fetchInstruction(newState);\n  let overridePc = false;\n\n  if (newState.skipping && instruction !== \"]\") {\n    newState.programCounter++;\n    return newState;\n  }\n\n  switch (instruction) {\n    case \">\":\n      newState.dataPointer++;\n      break;\n    case \"<\":\n      newState.dataPointer--;\n      break;\n    case \"+\":\n      writeMemory(newState, readMemory(newState) + 1);\n      break;\n    case \"-\":\n      writeMemory(newState, readMemory(newState) - 1);\n      break;\n    case \",\":\n      // When the program is blocked, do not attempt to read again\n      if (newState.blocked) return newState;\n\n      newState.stdin = ioReducer(newState.stdin, { type: \"read\", data: 1 });\n      if (newState.stdin.pendingSize > 0) {\n        // The stream is blocked, do not proceed\n        // The only way to resolve a blocked stream is to dispatch `write`\n        newState.blocked = true;\n        return newState;\n      }\n      writeMemory(newState, newState.stdin.readBuffer[0]);\n      if (newState.stdin.readBuffer[0] === undefined)\n        throw new Error(`invalid write ${newState.stdin}`);\n      break;\n    case \".\":\n      newState.stdout = ioReducer(newState.stdout, { type: \"write\", data: readMemory(newState) });\n      break;\n    case \"[\":\n      if (readMemory(newState) !== 0) {\n        // We can jump back to this point\n        newState.jmpStack.push(newState.programCounter);\n      } else {\n        // Skip the entire loop body until we reaches the corresponding ]\n        newState.skipping = true;\n      }\n      break;\n    case \"]\":\n      if (readMemory(newState) === 0) {\n        // When the data pointer becomes 0, reset the stack and continue\n        newState.jmpStack.pop();\n      } else {\n        // Jump back to the top of the jmpStack\n        newState.programCounter = newState.jmpStack[newState.jmpStack.length - 1] + 1;\n        overridePc = true;\n      }\n      break;\n  }\n\n  if (!overridePc) newState.programCounter++;\n\n  return newState;\n};\n\n/**\n * Write directly to the standard input stream\n */\nconst writeToStdin = (state: ProgramState, data: number[]) => {\n  let newState = copyState(state);\n  newState.stdin = ioReducer(newState.stdin, { type: \"write\", data: data });\n  if (newState.stdin.pendingSize === 0) {\n    newState.blocked = false;\n  }\n\n  return newState;\n};\n\nexport const brainfuckReducer = (\n  state: ProgramState,\n  action: BrainfuckCoreAction\n): ProgramState => {\n  switch (action.type) {\n    case \"next\":\n      return next(state);\n    case \"write\":\n      return writeToStdin(state, action.data);\n  }\n};\n","type TreeNode<V> = {\n  size: number;\n  key: number;\n  value: V;\n  left?: TreeNode<V>;\n  right?: TreeNode<V>;\n};\n\nconst buildTree = <V>(data: V[], start: number, end: number): TreeNode<V> => {\n  if (start > end) throw new Error(\"Cannot parse an empty array\");\n\n  const mid = start + Math.floor((end - start) / 2);\n  const left = start < mid ? buildTree(data, start, mid - 1) : undefined;\n  const right = end > mid ? buildTree(data, mid + 1, end) : undefined;\n  return {\n    size: (left?.size ?? 0) + (right?.size ?? 0) + 1,\n    key: mid,\n    value: data[mid],\n    left: left,\n    right: right,\n  };\n};\n\nconst queryTree = <V>(key: number, node?: TreeNode<V>): V => {\n  if (!!!node) throw new Error(\"List index out of bounds\");\n  if (node.key === key) return node.value;\n\n  return node.key > key ? queryTree(key, node.left) : queryTree(key, node.right);\n};\n\nconst updateTree = <V>(key: number, value: V, node?: TreeNode<V>): TreeNode<V> => {\n  if (!!!node) throw new Error(\"List index out of bounds\");\n  let newNode = Object.assign({}, node);\n\n  if (newNode.key === key) {\n    newNode.value = value;\n    return newNode;\n  }\n\n  if (newNode.key > key) {\n    newNode.left = updateTree(key, value, newNode.left);\n  } else {\n    newNode.right = updateTree(key, value, newNode.right);\n  }\n\n  return newNode;\n};\n\nconst sliceTree = <V>(result: V[], start: number, end: number, node?: TreeNode<V>) => {\n  if (!!!node) throw new Error(\"List index out of range\");\n\n  if (node.left) sliceTree(result, start, end, node.left);\n  if (node.key >= start && node.key < end) result.push(node.value);\n  if (node.right) sliceTree(result, start, end, node.right);\n};\n\nconst createList = <V>(data: V[]): List<V> => new List({ fromArray: true, array: data });\n\nexport class List<V> {\n  root: TreeNode<V>;\n  constructor(data: { fromArray: true; array: V[] } | { fromArray: false; root: TreeNode<V> }) {\n    if (data.fromArray) {\n      this.root = buildTree(data.array, 0, data.array.length - 1);\n    } else {\n      this.root = data.root;\n    }\n  }\n\n  query(key: number): V {\n    return queryTree(key, this.root);\n  }\n\n  /**\n   * Perform an efficient immutable update to the list\n   */\n  update(key: number, value: V): List<V> {\n    const newRoot = updateTree(key, value, this.root);\n    return new List({ fromArray: false, root: newRoot });\n  }\n\n  slice(start: number, end: number): V[] {\n    let result: V[] = [];\n    sliceTree(result, start, end, this.root);\n    return result;\n  }\n\n  size(): number {\n    return this.root.size;\n  }\n}\n\nexport default createList;\n","import { IOStream } from \"./IOStream\";\nimport createList from \"./ImmutableList\";\nimport { ProgramState, Instruction, brainfuckReducer, isEnded } from \"./Interpreter\";\n\nexport type RunResult = {\n  finalState: ProgramState;\n  numCycles: number;\n  ended: boolean;\n};\n\nconst MEMORY_SIZE = 30000;\nexport const MAX_PROGRAM_CYCLES = 2 << 16;\n\nexport const setupProgram = (\n  program: Instruction[],\n  stdin: IOStream,\n  stdout: IOStream\n): ProgramState => ({\n  programCounter: 0,\n  dataPointer: 0,\n  memory: createList(Array(MEMORY_SIZE).fill(0)),\n  jmpStack: [],\n  program: program,\n\n  skipping: false,\n  blocked: false,\n\n  stdin: stdin,\n  stdout: stdout,\n});\n\nexport const runCycles = (state: ProgramState, cycles: number): RunResult => {\n  let cyclesCount = 0;\n  while (!isEnded(state) && cyclesCount++ < cycles) {\n    state = brainfuckReducer(state, { type: \"next\" });\n  }\n  return {\n    finalState: state,\n    numCycles: cyclesCount,\n    ended: isEnded(state),\n  };\n};\n\nexport const run = (state: ProgramState): RunResult => {\n  let cycles = 0;\n  while (!isEnded(state) && ++cycles < MAX_PROGRAM_CYCLES) {\n    state = brainfuckReducer(state, { type: \"next\" });\n  }\n\n  if (cycles === MAX_PROGRAM_CYCLES && !isEnded(state)) {\n    console.error(\"Time limit exceed\");\n  }\n\n  return {\n    finalState: state,\n    numCycles: cycles,\n    ended: isEnded(state),\n  };\n};\n","export const ASCIIsToString = (n: number[]): string => String.fromCharCode(...n);\nexport const stringToASCIIs = (s: string): number[] => Array.from(s).map((c) => c.charCodeAt(0));\n","import { useCallback, useMemo, useState } from \"react\";\n\nimport { initializeIOStream } from \"../core/IOStream\";\nimport { brainfuckReducer, Instruction, parse, ProgramState } from \"../core/Interpreter\";\nimport { run, setupProgram } from \"../core/Runner\";\nimport { stringToASCIIs } from \"../core/utils\";\nimport { ReducerAction, ReducerHookReturnType } from \"../types\";\n\nexport type BrainfuckAction =\n  | ReducerAction<\"load\", string>\n  | ReducerAction<\"next\" | \"reset\" | \"run\">\n  | ReducerAction<\"write\", string>;\nconst DEFAULT_STREAM_SIZE = 2 << 10;\nconst setup = (parsed: Instruction[]) =>\n  setupProgram(\n    parsed,\n    initializeIOStream(DEFAULT_STREAM_SIZE),\n    initializeIOStream(DEFAULT_STREAM_SIZE)\n  );\n\nexport const useBrainfuck = (\n  initialProgram: string = \"\"\n): ReducerHookReturnType<ProgramState, BrainfuckAction> => {\n  const [program, setProgram] = useState(initialProgram);\n  const parsedProgram = useMemo(() => {\n    return parse(program);\n  }, [program]);\n  const [programState, setProgramState] = useState<ProgramState>(setup(parsedProgram));\n\n  const dispatch = useCallback(\n    (action: BrainfuckAction) => {\n      switch (action.type) {\n        case \"load\":\n          setProgram(action.data);\n          break;\n        case \"next\":\n          setProgramState((programState) => brainfuckReducer(programState, { type: \"next\" }));\n          break;\n        case \"run\":\n          setProgramState((programState) => run(programState).finalState);\n          break;\n        case \"reset\":\n          setProgramState(setup(parsedProgram));\n          break;\n        case \"write\":\n          setProgramState((programState) =>\n            brainfuckReducer(programState, { type: \"write\", data: stringToASCIIs(action.data) })\n          );\n          break;\n      }\n    },\n    [setProgram, setProgramState, parsedProgram]\n  );\n\n  return [programState, dispatch];\n};\n","import { useMemo, useState } from \"react\";\n\nimport { BrainfuckAction } from \"../hooks/useBrainfuck\";\n\nimport \"../css/Console.css\";\n\nimport { ProgramState } from \"../core/Interpreter\";\nimport { ASCIIsToString } from \"../core/utils\";\n\nexport type ConsoleProps = {\n  programState: ProgramState;\n  dispatch: (action: BrainfuckAction) => void;\n};\n\nconst Console = ({ programState, dispatch }: ConsoleProps) => {\n  const [inputText, setInputText] = useState(\"\");\n  const ioBuffers = useMemo(\n    () => ({\n      output: ASCIIsToString(programState.stdout.buffer),\n      input: ASCIIsToString(programState.stdin.buffer),\n    }),\n    [programState]\n  );\n\n  return (\n    <div>\n      <div className=\"console\">\n        <div>{ioBuffers.output}</div>\n      </div>\n      <div className=\"console with-input\">\n        <div>{ioBuffers.input}</div>\n        <div className=\"console-input\">\n          <input\n            value={inputText}\n            onKeyUp={(e) => {\n              if (e.key === \"Enter\") {\n                dispatch({ type: \"write\", data: inputText });\n                setInputText(\"\");\n              }\n            }}\n            onChange={(e) => setInputText(e.target.value)}\n          />\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default Console;\n","import { BrainfuckAction } from \"../hooks/useBrainfuck\";\n\nimport \"../css/ControlPanel.css\";\n\nimport { ProgramState, isEnded, isStarted } from \"../core/Interpreter\";\n\nexport type ControlPanelProps = {\n  programState: ProgramState;\n  dispatch: (action: BrainfuckAction) => void;\n};\n\nconst ControlPanel = ({ programState, dispatch }: ControlPanelProps) => {\n  return (\n    <ul className=\"panel\">\n      <li>\n        <button className=\"btn\" onClick={() => dispatch({ type: \"run\" })}>\n          Run\n        </button>\n      </li>\n      <li>\n        <button\n          className=\"btn\"\n          onClick={() => dispatch({ type: \"next\" })}\n          disabled={isEnded(programState) || programState.blocked}\n        >\n          {isStarted(programState) ? `Step${(programState.blocked ? \" (input required)\":\"\")}` : \"Start\"}\n        </button>\n      </li>\n      <li>\n        <button className=\"btn\" onClick={() => dispatch({ type: \"reset\" })}>\n          Reset\n        </button>\n      </li>\n    </ul>\n  );\n};\n\nexport default ControlPanel;\n","import CodeEditor from \"@uiw/react-textarea-code-editor\";\n\nexport type EditorProps = {\n  code: string;\n  setCode: (val: string) => void;\n  enabled: boolean;\n};\n\nconst Editor = ({ code, setCode, enabled }: EditorProps) => {\n  return (\n    <CodeEditor\n      value={code}\n      language=\"brainfuck\"\n      placeholder=\"brainfuck program here\"\n      onChange={(val) => setCode(val.target.value)}\n      padding={10}\n      style={{\n        fontSize: \"1.2rem\",\n      }}\n      disabled={!enabled}\n    />\n  );\n};\n\nexport default Editor;\n","import \"../css/Visualization.css\";\n\nimport { isStarted, ProgramState } from \"../core/Interpreter\";\n\nexport type VisualizationProps = {\n  programState: ProgramState;\n};\n\nconst Visualization = ({ programState }: VisualizationProps) => {\n  const isCurrentPc = (pc: number) =>\n    (!programState.blocked &&\n      (pc === programState.programCounter - 1\n        || (pc === 0 && programState.programCounter === 0)\n      )\n    )\n    || (programState.blocked && pc === programState.programCounter);\n\n  return (\n    <div>\n      <p>program counter: {programState.programCounter}{(programState.blocked ? \" (waiting for input)\" : \"\")}</p>\n      <p>data pointer: {programState.dataPointer}</p>\n      <p>current data: {programState.memory.query(programState.dataPointer)}</p>\n      <p>memory size: {programState.memory.size()}</p>\n      <div className=\"program-field\">\n        {programState.program.map((instruction, index) => (\n          <span\n            key={index}\n            className={isStarted(programState) && isCurrentPc(index) ? \"highlighted\" : \"\"}\n          >\n            {instruction}\n          </span>\n        ))}\n      </div>\n    </div>\n  );\n};\n\nexport default Visualization;\n","import { useEffect, useState } from \"react\";\n\nimport { useBrainfuck } from \"../hooks/useBrainfuck\";\n\nimport \"../css/App.css\";\n\nimport Console from \"./Console\";\nimport ControlPanel from \"./ControlPanel\";\nimport Editor from \"./Editor\";\nimport Visualization from \"./Visualization\";\n\nfunction App() {\n  const [code, setCode] = useState(\"\");\n  const [brainfuck, dispatch] = useBrainfuck(code);\n  const [editorEnabled] = useState(true);\n\n  useEffect(() => {\n    dispatch({ type: \"load\", data: code });\n    dispatch({ type: \"reset\" });\n  }, [code, dispatch]);\n\n  return (\n    <div className=\"App\">\n      <main className=\"App-main\">\n        <div>\n          <h1 id=\"center\">react-brainfucked</h1>\n        </div>\n        <div>\n          <Editor code={code} setCode={setCode} enabled={editorEnabled} />\n          <Visualization programState={brainfuck} />\n          <ControlPanel programState={brainfuck} dispatch={dispatch} />\n          <Console programState={brainfuck} dispatch={dispatch} />\n        </div>\n      </main>\n    </div>\n  );\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\n\nimport App from \"./components/App\";\n\nimport \"./css/index.css\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}