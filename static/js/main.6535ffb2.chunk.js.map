{"version":3,"sources":["core/IOStream.ts","core/Interpreter.ts","core/ImmutableList.ts","core/Runner.ts","core/utils.ts","hooks/useBrainfuck.ts","components/Console.tsx","components/ControlPanel.tsx","components/Editor.tsx","components/Visualization.tsx","components/App.tsx","index.tsx"],"names":["copyStream","stream","buffer","slice","readBuffer","initializeIOStream","size","pointer","readPointer","pendingSize","ioReducer","action","type","newStream","length","read","data","concat","Math","max","write","index","seek","instructionSet","Set","copyState","state","readMemory","memory","query","dataPointer","writeMemory","update","isEnded","programCounter","program","isStarted","blocked","parse","output","startsWith","count","s","has","push","brainfuckReducer","newState","instruction","fetchInstruction","overridePc","skipping","stdin","undefined","Error","stdout","jmpStack","pop","next","writeToStdin","buildTree","start","end","mid","floor","left","right","key","value","queryTree","node","updateTree","newNode","Object","assign","sliceTree","result","List","root","fromArray","this","array","createList","MAX_PROGRAM_CYCLES","run","cycles","console","error","finalState","numCycles","ended","ASCIIsToString","n","String","fromCharCode","stringToASCIIs","Array","from","map","c","charCodeAt","setup","parsed","fill","Console","programState","dispatch","useState","inputText","setInputText","ioBuffers","useMemo","input","className","placeholder","onKeyUp","e","onChange","target","ControlPanel","onClick","disabled","Editor","code","setCode","enabled","language","val","padding","style","border","borderRadius","Visualization","pc","App","initialProgram","setProgram","parsedProgram","setProgramState","useCallback","useBrainfuck","brainfuck","editorEnabled","useEffect","id","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.6535ffb2.chunk.js","sourcesContent":["import { ReducerAction } from \"../types\";\n\nexport type IOAction =\n  | ReducerAction<\"read\" | \"seek\", number>\n  | ReducerAction<\"write\", number | number[]>;\nexport type IOStream = {\n  buffer: number[];\n  size: number;\n  pointer: number;\n  // The buffer for the last read\n  readPointer: number;\n  readBuffer: number[];\n  pendingSize: number;\n};\n\nexport type ReadOutput = [stream: IOStream, data: number];\n\nconst copyStream = (stream: IOStream) => ({\n  ...stream,\n  buffer: stream.buffer.slice(0),\n  readBuffer: stream.readBuffer.slice(0),\n});\n\n/**\n * When the stream is blocked (pendingSize > 0), no data will be read into the buffer\n */\nexport const read = (stream: IOStream, size: number): IOStream => {\n  let newStream = copyStream(stream);\n  if (newStream.pendingSize > 0 || newStream.buffer.length <= newStream.readPointer) {\n    newStream.pendingSize += size;\n    return newStream;\n  }\n\n  // Read `size` of bytes from the buffer\n  newStream.readBuffer = newStream.buffer.slice(\n    newStream.readPointer,\n    newStream.readPointer + size\n  );\n\n  newStream.readPointer = newStream.readPointer + newStream.readBuffer.length;\n  if (newStream.readBuffer.length < size) {\n    // We haven't read enough bytes, expect more inputs\n    newStream.pendingSize += size - newStream.readBuffer.length;\n  }\n\n  return newStream;\n};\n\nexport const write = (stream: IOStream, data: number | number[]): IOStream => {\n  if (typeof data == \"number\") data = [data];\n\n  let newStream = copyStream(stream);\n  newStream.buffer = newStream.buffer.slice(0, newStream.pointer).concat(data);\n  newStream.pointer += data.length;\n\n  if (newStream.pendingSize > 0) {\n    // Prevent pendingSize from underflowing\n    newStream.pendingSize = Math.max(newStream.pendingSize - data.length, 0);\n  }\n\n  return newStream;\n};\n\nconst seek = (stream: IOStream, index: number): IOStream => {\n  let newStream = copyStream(stream);\n  newStream.pointer = index;\n  newStream.readPointer = index;\n  return newStream;\n};\n\nexport const initializeIOStream = (size: number): IOStream => ({\n  buffer: [],\n  size: size,\n  pointer: 0,\n  readPointer: 0,\n  readBuffer: [],\n  pendingSize: 0,\n});\n\nexport const ioReducer = (stream: IOStream, action: IOAction): IOStream => {\n  switch (action.type) {\n    case \"read\":\n      return read(stream, action.data);\n    case \"write\":\n      return write(stream, action.data);\n    case \"seek\":\n      return seek(stream, action.data);\n  }\n};\n","import { ReducerAction } from \"../types\";\nimport { ioReducer, IOStream } from \"./IOStream\";\nimport { List } from \"./ImmutableList\";\n\nexport type BrainfuckCoreAction = ReducerAction<\"next\"> | ReducerAction<\"write\", number[]>;\nconst instructionSet = new Set([\"<\", \">\", \",\", \".\", \"[\", \"]\", \"+\", \"-\"]);\nexport type Instruction = \"<\" | \">\" | \",\" | \".\" | \"[\" | \"]\" | \"+\" | \"-\";\n\nexport type ProgramState = {\n  programCounter: number;\n  dataPointer: number;\n  memory: List<number>;\n  jmpStack: number[];\n  program: Instruction[];\n\n  skipping: boolean;\n  blocked: boolean;\n\n  stdin: IOStream;\n  stdout: IOStream;\n};\n\nconst copyState = (state: ProgramState): ProgramState => ({\n  ...state,\n});\n\nconst readMemory = (state: ProgramState) => state.memory.query(state.dataPointer);\nconst writeMemory = (state: ProgramState, data: number) =>\n  (state.memory = state.memory.update(state.dataPointer, data));\nconst fetchInstruction = (state: ProgramState): Instruction => state.program[state.programCounter];\n\nexport const isEnded = (state: ProgramState) => state.programCounter === state.program.length;\nexport const isStarted = (state: ProgramState) => state.programCounter > 0 || state.blocked;\n\n/**\n * Parse out the initial loop and ignore non-instruction characters\n */\nexport const parse = (program: string): Instruction[] => {\n  let output: any = [];\n  if (program.startsWith(\"[\")) {\n    let count = 1,\n      index = 1;\n    while (count > 0) {\n      if (program[index] === \"[\") {\n        count++;\n      }\n      if (program[index] === \"]\") {\n        count--;\n      }\n      if (index > 30000) {\n        return [];\n      }\n      index++;\n    }\n    program = program.slice(index + 1);\n  }\n\n  for (let s of program) {\n    if (instructionSet.has(s)) {\n      output.push(s);\n    }\n  }\n  return output;\n};\n\nconst next = (state: ProgramState): ProgramState => {\n  if (isEnded(state)) return state;\n\n  let newState = copyState(state);\n\n  const instruction = fetchInstruction(newState);\n  let overridePc = false;\n\n  if (newState.skipping && instruction !== \"]\") {\n    newState.programCounter++;\n    return newState;\n  }\n\n  switch (instruction) {\n    case \">\":\n      newState.dataPointer++;\n      break;\n    case \"<\":\n      newState.dataPointer--;\n      break;\n    case \"+\":\n      writeMemory(newState, readMemory(newState) + 1);\n      break;\n    case \"-\":\n      writeMemory(newState, readMemory(newState) - 1);\n      break;\n    case \",\":\n      // When the program is blocked, do not attempt to read again\n      if (newState.blocked) return newState;\n\n      newState.stdin = ioReducer(newState.stdin, { type: \"read\", data: 1 });\n      if (newState.stdin.pendingSize > 0) {\n        // The stream is blocked, do not proceed\n        // The only way to resolve a blocked stream is to dispatch `write`\n        newState.blocked = true;\n        return newState;\n      }\n      writeMemory(newState, newState.stdin.readBuffer[0]);\n      if (newState.stdin.readBuffer[0] === undefined)\n        throw new Error(`invalid write ${newState.stdin}`);\n      break;\n    case \".\":\n      newState.stdout = ioReducer(newState.stdout, { type: \"write\", data: readMemory(newState) });\n      break;\n    case \"[\":\n      if (readMemory(newState) !== 0) {\n        // We can jump back to this point\n        newState.jmpStack.push(newState.programCounter);\n      } else {\n        // Skip the entire loop body until we reaches the corresponding ]\n        newState.skipping = true;\n      }\n      break;\n    case \"]\":\n      if (readMemory(newState) === 0) {\n        // When the data pointer becomes 0, reset the stack and continue\n        newState.jmpStack.pop();\n      } else {\n        // Jump back to the top of the jmpStack\n        newState.programCounter = newState.jmpStack[newState.jmpStack.length - 1] + 1;\n        overridePc = true;\n      }\n      break;\n  }\n\n  if (!overridePc) newState.programCounter++;\n\n  return newState;\n};\n\n/**\n * Write directly to the standard input stream\n */\nconst writeToStdin = (state: ProgramState, data: number[]) => {\n  let newState = copyState(state);\n  newState.stdin = ioReducer(newState.stdin, { type: \"write\", data: data });\n  if (newState.stdin.pendingSize === 0) {\n    newState.blocked = false;\n  }\n\n  return newState;\n};\n\nexport const brainfuckReducer = (\n  state: ProgramState,\n  action: BrainfuckCoreAction\n): ProgramState => {\n  switch (action.type) {\n    case \"next\":\n      return next(state);\n    case \"write\":\n      return writeToStdin(state, action.data);\n  }\n};\n","type TreeNode<V> = {\n  size: number;\n  key: number;\n  value: V;\n  left?: TreeNode<V>;\n  right?: TreeNode<V>;\n};\n\nconst buildTree = <V>(data: V[], start: number, end: number): TreeNode<V> => {\n  if (start > end) throw new Error(\"Cannot parse an empty array\");\n\n  const mid = start + Math.floor((end - start) / 2);\n  const left = start < mid ? buildTree(data, start, mid - 1) : undefined;\n  const right = end > mid ? buildTree(data, mid + 1, end) : undefined;\n  return {\n    size: (left?.size ?? 0) + (right?.size ?? 0) + 1,\n    key: mid,\n    value: data[mid],\n    left: left,\n    right: right,\n  };\n};\n\nconst queryTree = <V>(key: number, node?: TreeNode<V>): V => {\n  if (!!!node) throw new Error(\"List index out of bounds\");\n  if (node.key === key) return node.value;\n\n  return node.key > key ? queryTree(key, node.left) : queryTree(key, node.right);\n};\n\nconst updateTree = <V>(key: number, value: V, node?: TreeNode<V>): TreeNode<V> => {\n  if (!!!node) throw new Error(\"List index out of bounds\");\n  let newNode = Object.assign({}, node);\n\n  if (newNode.key === key) {\n    newNode.value = value;\n    return newNode;\n  }\n\n  if (newNode.key > key) {\n    newNode.left = updateTree(key, value, newNode.left);\n  } else {\n    newNode.right = updateTree(key, value, newNode.right);\n  }\n\n  return newNode;\n};\n\nconst sliceTree = <V>(result: V[], start: number, end: number, node?: TreeNode<V>) => {\n  if (!!!node) throw new Error(\"List index out of range\");\n\n  if (node.left) sliceTree(result, start, end, node.left);\n  if (node.key >= start && node.key < end) result.push(node.value);\n  if (node.right) sliceTree(result, start, end, node.right);\n};\n\nconst createList = <V>(data: V[]): List<V> => new List({ fromArray: true, array: data });\n\nexport class List<V> {\n  root: TreeNode<V>;\n  constructor(data: { fromArray: true; array: V[] } | { fromArray: false; root: TreeNode<V> }) {\n    if (data.fromArray) {\n      this.root = buildTree(data.array, 0, data.array.length - 1);\n    } else {\n      this.root = data.root;\n    }\n  }\n\n  query(key: number): V {\n    return queryTree(key, this.root);\n  }\n\n  /**\n   * Perform an efficient immutable update to the list\n   */\n  update(key: number, value: V): List<V> {\n    const newRoot = updateTree(key, value, this.root);\n    return new List({ fromArray: false, root: newRoot });\n  }\n\n  slice(start: number, end: number): V[] {\n    let result: V[] = [];\n    sliceTree(result, start, end, this.root);\n    return result;\n  }\n\n  size(): number {\n    return this.root.size;\n  }\n}\n\nexport default createList;\n","import { IOStream } from \"./IOStream\";\nimport createList from \"./ImmutableList\";\nimport { ProgramState, Instruction, brainfuckReducer, isEnded } from \"./Interpreter\";\n\nexport type RunResult = {\n  finalState: ProgramState;\n  numCycles: number;\n  ended: boolean;\n};\n\nconst MEMORY_SIZE = 30000;\nexport const MAX_PROGRAM_CYCLES = 2 << 16;\n\nexport const setupProgram = (\n  program: Instruction[],\n  stdin: IOStream,\n  stdout: IOStream\n): ProgramState => ({\n  programCounter: 0,\n  dataPointer: 0,\n  memory: createList(Array(MEMORY_SIZE).fill(0)),\n  jmpStack: [],\n  program: program,\n\n  skipping: false,\n  blocked: false,\n\n  stdin: stdin,\n  stdout: stdout,\n});\n\nexport const runCycles = (state: ProgramState, cycles: number): RunResult => {\n  let cyclesCount = 0;\n  while (!isEnded(state) && cyclesCount++ < cycles) {\n    state = brainfuckReducer(state, { type: \"next\" });\n  }\n  return {\n    finalState: state,\n    numCycles: cyclesCount,\n    ended: isEnded(state),\n  };\n};\n\nexport const run = (state: ProgramState): RunResult => {\n  let cycles = 0;\n  while (!isEnded(state) && ++cycles < MAX_PROGRAM_CYCLES) {\n    state = brainfuckReducer(state, { type: \"next\" });\n  }\n\n  if (cycles === MAX_PROGRAM_CYCLES && !isEnded(state)) {\n    console.error(\"Time limit exceed\");\n  }\n\n  return {\n    finalState: state,\n    numCycles: cycles,\n    ended: isEnded(state),\n  };\n};\n","export const ASCIIsToString = (n: number[]): string => String.fromCharCode(...n);\nexport const stringToASCIIs = (s: string): number[] => Array.from(s).map((c) => c.charCodeAt(0));\n","import { useCallback, useMemo, useState } from \"react\";\n\nimport { initializeIOStream } from \"../core/IOStream\";\nimport { brainfuckReducer, Instruction, parse, ProgramState } from \"../core/Interpreter\";\nimport { run, setupProgram } from \"../core/Runner\";\nimport { stringToASCIIs } from \"../core/utils\";\nimport { ReducerAction, ReducerHookReturnType } from \"../types\";\n\nexport type BrainfuckAction =\n  | ReducerAction<\"load\", string>\n  | ReducerAction<\"next\" | \"reset\" | \"run\">\n  | ReducerAction<\"write\", string>;\nconst DEFAULT_STREAM_SIZE = 2 << 10;\nconst setup = (parsed: Instruction[]) =>\n  setupProgram(\n    parsed,\n    initializeIOStream(DEFAULT_STREAM_SIZE),\n    initializeIOStream(DEFAULT_STREAM_SIZE)\n  );\n\nexport const useBrainfuck = (\n  initialProgram: string = \"\"\n): ReducerHookReturnType<ProgramState, BrainfuckAction> => {\n  const [program, setProgram] = useState(initialProgram);\n  const parsedProgram = useMemo(() => {\n    return parse(program);\n  }, [program]);\n  const [programState, setProgramState] = useState<ProgramState>(setup(parsedProgram));\n\n  const dispatch = useCallback(\n    (action: BrainfuckAction) => {\n      switch (action.type) {\n        case \"load\":\n          setProgram(action.data);\n          break;\n        case \"next\":\n          setProgramState((programState) => brainfuckReducer(programState, { type: \"next\" }));\n          break;\n        case \"run\":\n          setProgramState((programState) => run(programState).finalState);\n          break;\n        case \"reset\":\n          setProgramState(setup(parsedProgram));\n          break;\n        case \"write\":\n          setProgramState((programState) =>\n            brainfuckReducer(programState, { type: \"write\", data: stringToASCIIs(action.data) })\n          );\n          break;\n      }\n    },\n    [setProgram, setProgramState, parsedProgram]\n  );\n\n  return [programState, dispatch];\n};\n","import { useMemo, useState } from \"react\";\n\nimport { BrainfuckAction } from \"../hooks/useBrainfuck\";\n\nimport \"../css/Console.css\";\n\nimport { ProgramState } from \"../core/Interpreter\";\nimport { ASCIIsToString } from \"../core/utils\";\n\nexport type ConsoleProps = {\n  programState: ProgramState;\n  dispatch: (action: BrainfuckAction) => void;\n};\n\nconst Console = ({ programState, dispatch }: ConsoleProps) => {\n  const [inputText, setInputText] = useState(\"\");\n  const ioBuffers = useMemo(\n    () => ({\n      output: ASCIIsToString(programState.stdout.buffer),\n      input: ASCIIsToString(programState.stdin.buffer),\n    }),\n    [programState]\n  );\n\n  return (\n    <div>\n      <p>Output</p>\n      <div className=\"console\">\n        <div className=\"console-text\">\n          <pre>{ioBuffers.output}</pre>\n        </div>\n      </div>\n      <p>Input</p>\n      <div className=\"console with-input\">\n        <div className=\"console-text\">\n          <pre>{ioBuffers.input}</pre>\n        </div>\n        <div className=\"console-input\">\n          <input\n            placeholder=\"This is the console\"\n            value={inputText}\n            onKeyUp={(e) => {\n              if (e.key === \"Enter\") {\n                dispatch({ type: \"write\", data: inputText });\n                setInputText(\"\");\n              }\n            }}\n            onChange={(e) => setInputText(e.target.value + \"\\n\")}\n          />\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default Console;\n","import { BrainfuckAction } from \"../hooks/useBrainfuck\";\n\nimport \"../css/ControlPanel.css\";\n\nimport { ProgramState, isEnded, isStarted } from \"../core/Interpreter\";\n\nexport type ControlPanelProps = {\n  programState: ProgramState;\n  dispatch: (action: BrainfuckAction) => void;\n};\n\nconst ControlPanel = ({ programState, dispatch }: ControlPanelProps) => {\n  return (\n    <>\n      <p>\n        Control Panel{\" \"}\n        {programState.program.length === 0 && (\n          <span className=\"note\">(enter any bf program to get started)</span>\n        )}\n      </p>\n      <ul className=\"panel\">\n        <li>\n          <button\n            className=\"btn\"\n            onClick={() => dispatch({ type: \"run\" })}\n            disabled={programState.program.length === 0}\n          >\n            Run\n          </button>\n        </li>\n        <li>\n          <button\n            className=\"btn\"\n            onClick={() => dispatch({ type: \"next\" })}\n            disabled={isEnded(programState) || programState.blocked}\n          >\n            {isStarted(programState)\n              ? `Step${programState.blocked ? \" (input required)\" : \"\"}`\n              : \"Start\"}\n          </button>\n        </li>\n        <li>\n          <button\n            className=\"btn\"\n            onClick={() => dispatch({ type: \"reset\" })}\n            disabled={programState.program.length === 0}\n          >\n            Reset\n          </button>\n        </li>\n      </ul>\n    </>\n  );\n};\n\nexport default ControlPanel;\n","import CodeEditor from \"@uiw/react-textarea-code-editor\";\n\nexport type EditorProps = {\n  code: string;\n  setCode: (val: string) => void;\n  enabled: boolean;\n};\n\nconst Editor = ({ code, setCode, enabled }: EditorProps) => {\n  return (\n    <>\n      <p>Editor</p>\n      <CodeEditor\n        value={code}\n        language=\"brainfuck\"\n        placeholder=\"brainfuck program here\"\n        onChange={(val) => setCode(val.target.value)}\n        padding={10}\n        style={{\n          border: \"1px solid black\",\n          borderRadius: \"var(--border-radius)\",\n        }}\n        disabled={!enabled}\n      />\n    </>\n  );\n};\n\nexport default Editor;\n","import \"../css/Visualization.css\";\n\nimport { isStarted, ProgramState } from \"../core/Interpreter\";\n\nexport type VisualizationProps = {\n  programState: ProgramState;\n};\n\nconst Visualization = ({ programState }: VisualizationProps) => {\n  const isCurrentPc = (pc: number) =>\n    (!programState.blocked &&\n      (pc === programState.programCounter - 1 ||\n        (pc === 0 && programState.programCounter === 0))) ||\n    (programState.blocked && pc === programState.programCounter);\n\n  return (\n    <>\n      <p>Visualization</p>\n      <div className=\"visualization\">\n        <div className=\"program-field\">\n          {programState.program.map((instruction, index) => (\n            <span\n              key={index}\n              className={isStarted(programState) && isCurrentPc(index) ? \"highlighted\" : \"\"}\n            >\n              {instruction}\n            </span>\n          ))}\n          <p>parsed program</p>\n        </div>\n        <div>\n          <p>\n            program counter: {programState.programCounter}\n            {programState.blocked ? \" (waiting for input)\" : \"\"}\n          </p>\n          <p>data pointer: {programState.dataPointer}</p>\n          <p>current data: {programState.memory.query(programState.dataPointer)}</p>\n        </div>\n      </div>\n    </>\n  );\n};\n\nexport default Visualization;\n","import { useEffect, useState } from \"react\";\n\nimport { useBrainfuck } from \"../hooks/useBrainfuck\";\n\nimport \"../css/App.css\";\n\nimport Console from \"./Console\";\nimport ControlPanel from \"./ControlPanel\";\nimport Editor from \"./Editor\";\nimport Visualization from \"./Visualization\";\n\nfunction App() {\n  const [code, setCode] = useState(\"\");\n  const [brainfuck, dispatch] = useBrainfuck(code);\n  const [editorEnabled] = useState(true);\n\n  useEffect(() => {\n    dispatch({ type: \"load\", data: code });\n    dispatch({ type: \"reset\" });\n  }, [code, dispatch]);\n\n  return (\n    <div className=\"App\">\n      <main className=\"App-main\">\n        <div>\n          <h1 id=\"center\">react-brainfucked</h1>\n        </div>\n        <div>\n          <Editor code={code} setCode={setCode} enabled={editorEnabled} />\n          <Visualization programState={brainfuck} />\n          <ControlPanel programState={brainfuck} dispatch={dispatch} />\n          <Console programState={brainfuck} dispatch={dispatch} />\n        </div>\n      </main>\n    </div>\n  );\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\n\nimport App from \"./components/App\";\n\nimport \"./css/index.css\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}