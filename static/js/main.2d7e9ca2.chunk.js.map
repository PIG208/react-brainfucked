{"version":3,"sources":["core/IOStream.ts","core/Interpreter.ts","tests/Fixtures.tsx","core/ImmutableList.ts","core/Runner.ts","core/utils.ts","hooks/useBrainfuck.ts","components/Console.tsx","components/ControlPanel.tsx","components/Editor.tsx","components/UserManual.tsx","components/Visualization.tsx","components/App.tsx","index.tsx"],"names":["copyStream","stream","buffer","slice","readBuffer","initializeIOStream","size","pointer","readPointer","pendingSize","ioReducer","action","type","newStream","length","read","data","concat","Math","max","write","index","seek","instructionSet","Set","copyState","state","breakpoints","readMemory","memory","query","dataPointer","writeMemory","update","fetchInstruction","program","programCounter","isEnded","isStarted","blocked","isPaused","blockType","parse","output","startsWith","count","loopForward","ImmutableMap","loopBackward","split","filter","s","has","i","leftBrackets","Map","push","loopBeginning","pop","undefined","set","console","error","next","continuing","newState","binarySearch","instruction","overridePc","stdin","Error","stdout","target","get","brainfuckReducer","writeToStdin","unblockBreakpoint","breakpoint","testHelloWorld","buildTree","start","end","mid","floor","left","right","key","value","queryTree","node","updateTree","newNode","Object","assign","sliceTree","result","List","root","fromArray","this","array","createList","MAX_PROGRAM_CYCLES","setupProgram","parsed","Array","fill","run","cycles","finalState","numCycles","ended","ASCIIsToString","n","String","fromCharCode","stringToASCIIs","from","map","c","charCodeAt","setup","Console","programState","dispatch","useState","inputText","setInputText","ioBuffers","useMemo","input","inputBuffer","className","placeholder","onKeyUp","e","onChange","ControlPanel","setCode","onClick","disabled","Editor","code","enabled","language","val","padding","style","border","borderRadius","UserManual","Visualization","currentBreakpointIndex","_","pc","App","initialProgram","setProgram","parsedProgram","setProgramState","useCallback","useBrainfuck","brainfuck","editorEnabled","useEffect","id","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.2d7e9ca2.chunk.js","sourcesContent":["import { ReducerAction } from \"../types\";\n\nexport type IOAction =\n  | ReducerAction<\"read\" | \"seek\", number>\n  | ReducerAction<\"write\", number | number[]>;\nexport type IOStream = {\n  buffer: number[];\n  size: number;\n  pointer: number;\n  // The buffer for the last read\n  readPointer: number;\n  readBuffer: number[];\n  pendingSize: number;\n};\n\nexport type ReadOutput = [stream: IOStream, data: number];\n\nconst copyStream = (stream: IOStream) => ({\n  ...stream,\n  buffer: stream.buffer.slice(0),\n  readBuffer: stream.readBuffer.slice(0),\n});\n\n/**\n * When the stream is blocked (pendingSize > 0), no data will be read into the buffer\n */\nexport const read = (stream: IOStream, size: number): IOStream => {\n  let newStream = copyStream(stream);\n  if (newStream.pendingSize > 0 || newStream.buffer.length <= newStream.readPointer) {\n    newStream.pendingSize += size;\n    return newStream;\n  }\n\n  // Read `size` of bytes from the buffer\n  newStream.readBuffer = newStream.buffer.slice(\n    newStream.readPointer,\n    newStream.readPointer + size\n  );\n\n  newStream.readPointer = newStream.readPointer + newStream.readBuffer.length;\n  if (newStream.readBuffer.length < size) {\n    // We haven't read enough bytes, expect more inputs\n    newStream.pendingSize += size - newStream.readBuffer.length;\n  }\n\n  return newStream;\n};\n\nexport const write = (stream: IOStream, data: number | number[]): IOStream => {\n  if (typeof data == \"number\") data = [data];\n\n  let newStream = copyStream(stream);\n  newStream.buffer = newStream.buffer.slice(0, newStream.pointer).concat(data);\n  newStream.pointer += data.length;\n\n  if (newStream.pendingSize > 0) {\n    // Prevent pendingSize from underflowing\n    newStream.pendingSize = Math.max(newStream.pendingSize - data.length, 0);\n  }\n\n  return newStream;\n};\n\nconst seek = (stream: IOStream, index: number): IOStream => {\n  let newStream = copyStream(stream);\n  newStream.pointer = index;\n  newStream.readPointer = index;\n  return newStream;\n};\n\nexport const initializeIOStream = (size: number): IOStream => ({\n  buffer: [],\n  size: size,\n  pointer: 0,\n  readPointer: 0,\n  readBuffer: [],\n  pendingSize: 0,\n});\n\nexport const ioReducer = (stream: IOStream, action: IOAction): IOStream => {\n  switch (action.type) {\n    case \"read\":\n      return read(stream, action.data);\n    case \"write\":\n      return write(stream, action.data);\n    case \"seek\":\n      return seek(stream, action.data);\n  }\n};\n","import binarySearch from \"binarysearch\";\n// External library for laziness (and performance)\nimport { Map as ImmutableMap } from \"immutable\";\n\nimport { ReducerAction } from \"../types\";\nimport { ioReducer, IOStream } from \"./IOStream\";\n// Homemade Immutable List just for fun\nimport { List } from \"./ImmutableList\";\n\nexport type BrainfuckCoreAction =\n  | ReducerAction<\"next\" | \"continue\">\n  | ReducerAction<\"breakpoint\", number>\n  | ReducerAction<\"write\", number[]>;\nconst instructionSet = new Set([\"<\", \">\", \",\", \".\", \"[\", \"]\", \"+\", \"-\"]);\nexport type Instruction = \"<\" | \">\" | \",\" | \".\" | \"[\" | \"]\" | \"+\" | \"-\";\nexport type BlockType = \"none\" | \"io\" | \"breakpoint\";\nexport type ParseResult = {\n  program: Instruction[];\n  loopForward: ImmutableMap<number, number>;\n  loopBackward: ImmutableMap<number, number>;\n};\n\nexport type ProgramState = {\n  programCounter: number;\n  dataPointer: number;\n  memory: List<number>;\n  program: Instruction[];\n\n  breakpoints: number[];\n  loopForward: ImmutableMap<number, number>;\n  loopBackward: ImmutableMap<number, number>;\n  blocked: boolean;\n  blockType: BlockType;\n\n  stdin: IOStream;\n  stdout: IOStream;\n};\n\nconst copyState = (state: ProgramState): ProgramState => ({\n  ...state,\n  // TODO: Implement immutable dynamic list\n  breakpoints: state.breakpoints.slice(0),\n});\n\nconst readMemory = (state: ProgramState) => state.memory.query(state.dataPointer);\nconst writeMemory = (state: ProgramState, data: number) =>\n  (state.memory = state.memory.update(state.dataPointer, data));\nconst fetchInstruction = (state: ProgramState): Instruction => state.program[state.programCounter];\n\nexport const isEnded = (state: ProgramState) => state.programCounter === state.program.length;\nexport const isStarted = (state: ProgramState) => state.programCounter > 0 || state.blocked;\nexport const isPaused = (state: ProgramState) => state.blockType === \"breakpoint\" && state.blocked;\n\n/**\n * Parse out the initial loop and ignore non-instruction characters\n */\nexport const parse = (program: string): ParseResult => {\n  let output: Instruction[] = [];\n  if (program.startsWith(\"[\")) {\n    let count = 1,\n      index = 1;\n    while (count > 0) {\n      if (program[index] === \"[\") {\n        count++;\n      }\n      if (program[index] === \"]\") {\n        count--;\n      }\n      if (index > 30000) {\n        return {\n          program: [],\n          loopForward: ImmutableMap(),\n          loopBackward: ImmutableMap(),\n        };\n      }\n      index++;\n    }\n    program = program.slice(index + 1);\n  }\n\n  output = program.split(\"\").filter((s) => instructionSet.has(s)) as any;\n\n  let i = 0;\n  let leftBrackets: number[] = [];\n  let loopForward = new Map<number, number>(),\n    loopBackward = new Map<number, number>();\n\n  for (; i < output.length; i++) {\n    if (output[i] === \"[\") {\n      leftBrackets.push(i);\n    } else if (output[i] === \"]\") {\n      let loopBeginning = leftBrackets.pop();\n      if (loopBeginning === undefined) break;\n\n      loopForward.set(loopBeginning, i);\n      loopBackward.set(i, loopBeginning);\n    }\n  }\n\n  if (leftBrackets.length > 0 || i < output.length) console.error(\"Unbalanced loops\");\n\n  return {\n    program: output,\n    loopForward: ImmutableMap(loopForward),\n    loopBackward: ImmutableMap(loopBackward),\n  };\n};\n\nconst next = (state: ProgramState, continuing: boolean = false): ProgramState => {\n  if (isEnded(state) || state.blocked) return state;\n\n  let newState = copyState(state);\n\n  if (binarySearch(newState.breakpoints, newState.programCounter) >= 0 && !continuing) {\n    // Breakpoint is triggered, it has a higher priority than the io block\n    newState.blocked = true;\n    newState.blockType = \"breakpoint\";\n    return newState;\n  }\n\n  const instruction = fetchInstruction(newState);\n  let overridePc = false;\n\n  switch (instruction) {\n    case \">\":\n      newState.dataPointer++;\n      break;\n    case \"<\":\n      newState.dataPointer--;\n      break;\n    case \"+\":\n      writeMemory(newState, readMemory(newState) + 1 % 256);\n      break;\n    case \"-\":\n      writeMemory(newState, (readMemory(newState) - 1 + 256) % 256);\n      break;\n    case \",\":\n      newState.stdin = ioReducer(newState.stdin, { type: \"read\", data: 1 });\n      if (newState.stdin.pendingSize > 0) {\n        // The stream is blocked, do not proceed\n        // The only way to resolve a blocked stream is to dispatch `write`\n        newState.blocked = true;\n        newState.blockType = \"io\";\n        return newState;\n      }\n      writeMemory(newState, newState.stdin.readBuffer[0]);\n      if (newState.stdin.readBuffer[0] === undefined)\n        throw new Error(`invalid write ${newState.stdin}`);\n      break;\n    case \".\":\n      newState.stdout = ioReducer(newState.stdout, { type: \"write\", data: readMemory(newState) });\n      break;\n    case \"[\":\n      if (readMemory(newState) === 0) {\n        // Skip the entire loop body until we reaches the corresponding ]\n        const target = newState.loopForward.get(newState.programCounter);\n        if (target === undefined) throw new Error(\"Cannot find the corresponding ]\");\n        newState.programCounter = target + 1;\n        overridePc = true;\n      }\n      break;\n    case \"]\":\n      if (readMemory(newState) !== 0) {\n        // Skip the entire loop body until we reaches the corresponding ]\n        const target = newState.loopBackward.get(newState.programCounter);\n        if (target === undefined) throw new Error(\"Cannot find the corresponding ]\");\n        newState.programCounter = target + 1;\n        overridePc = true;\n      }\n      break;\n  }\n\n  if (!overridePc) newState.programCounter++;\n\n  return newState;\n};\n\n/**\n * Write directly to the standard input stream\n */\nconst writeToStdin = (state: ProgramState, data: number[]) => {\n  let newState = copyState(state);\n  newState.stdin = ioReducer(newState.stdin, { type: \"write\", data: data });\n  if (newState.stdin.pendingSize === 0 && newState.blockType === \"io\") {\n    newState.blocked = false;\n    newState.blockType = \"none\";\n  }\n\n  return newState;\n};\n\nconst unblockBreakpoint = (state: ProgramState) => {\n  let newState = copyState(state);\n  if (newState.blocked && newState.blockType === \"breakpoint\") {\n    newState.blocked = false;\n    newState.blockType = \"none\";\n  }\n\n  return newState;\n};\n\nconst breakpoint = (state: ProgramState, breakpoint: number) => {\n  let newState = copyState(state);\n  for (let i = 0; i <= newState.breakpoints.length; i++) {\n    if (newState.breakpoints[i] === breakpoint) {\n      newState.breakpoints = newState.breakpoints\n        .slice(0, i)\n        .concat(newState.breakpoints.slice(i + 1, newState.breakpoints.length));\n      return newState;\n    }\n\n    if (i === newState.breakpoints.length || newState.breakpoints[i] > breakpoint) {\n      newState.breakpoints = newState.breakpoints\n        .slice(0, i)\n        .concat([breakpoint], newState.breakpoints.slice(i, newState.breakpoints.length));\n      return newState;\n    }\n  }\n\n  return newState;\n};\n\nexport const brainfuckReducer = (\n  state: ProgramState,\n  action: BrainfuckCoreAction\n): ProgramState => {\n  switch (action.type) {\n    case \"next\":\n      return next(state);\n    case \"write\":\n      return writeToStdin(state, action.data);\n    case \"continue\":\n      return next(unblockBreakpoint(state), true);\n    case \"breakpoint\":\n      return breakpoint(state, action.data);\n  }\n};\n","import { IOStream } from \"../core/IOStream\";\nimport { Instruction } from \"../core/Interpreter\";\n\nexport const MockStream = (content: string = \"\"): IOStream => ({\n  buffer: Array.from(content).map((c) => c.charCodeAt(0)),\n  size: Infinity,\n  pointer: 0,\n  readPointer: 0,\n  readBuffer: [],\n  pendingSize: 0,\n});\n\nexport type Fixture = {\n  raw: string;\n  parsed: Instruction[];\n};\n\nexport const testHelloWorld: Fixture = {\n  raw: `[ This program prints \"Hello World!\" and a newline to the screen, its\nlength is 106 active command characters. [It is not the shortest.]\n\nThis loop is an \"initial comment loop\", a simple way of adding a comment\nto a BF program such that you don't have to worry about any command\ncharacters. Any \".\", \",\", \"+\", \"-\", \"<\" and \">\" characters are simply\nignored, the \"[\" and \"]\" characters just have to be balanced. This\nloop and the commands it contains are ignored because the current cell\ndefaults to a value of 0; the 0 value causes this loop to be skipped.\n]\n++++++++               Set Cell #0 to 8\n[\n  >++++               Add 4 to Cell #1; this will always set Cell #1 to 4\n  [                   as the cell will be cleared by the loop\n      >++             Add 2 to Cell #2\n      >+++            Add 3 to Cell #3\n      >+++            Add 3 to Cell #4\n      >+              Add 1 to Cell #5\n      <<<<-           Decrement the loop counter in Cell #1\n  ]                   Loop until Cell #1 is zero; number of iterations is 4\n  >+                  Add 1 to Cell #2\n  >+                  Add 1 to Cell #3\n  >-                  Subtract 1 from Cell #4\n  >>+                 Add 1 to Cell #6\n  [<]                 Move back to the first zero cell you find; this will\n                      be Cell #1 which was cleared by the previous loop\n  <-                  Decrement the loop Counter in Cell #0\n]                       Loop until Cell #0 is zero; number of iterations is 8\n\nThe result of this is:\nCell no :   0   1   2   3   4   5   6\nContents:   0   0  72 104  88  32   8\nPointer :   ^\n\n>>.                     Cell #2 has value 72 which is 'H'\n>---.                   Subtract 3 from Cell #3 to get 101 which is 'e'\n+++++++..+++.           Likewise for 'llo' from Cell #3\n>>.                     Cell #5 is 32 for the space\n<-.                     Subtract 1 from Cell #4 for 87 to give a 'W'\n<.                      Cell #3 was set to 'o' from the end of 'Hello'\n+++.------.--------.    Cell #3 for 'rl' and 'd'\n>>+.                    Add 1 to Cell #5 gives us an exclamation point\n>++.                    And finally a newline from Cell #6`,\n  parsed: [\n    \"+\",\n    \"+\",\n    \"+\",\n    \"+\",\n    \"+\",\n    \"+\",\n    \"+\",\n    \"+\",\n    \"[\",\n    \">\",\n    \"+\",\n    \"+\",\n    \"+\",\n    \"+\",\n    \"[\",\n    \">\",\n    \"+\",\n    \"+\",\n    \">\",\n    \"+\",\n    \"+\",\n    \"+\",\n    \">\",\n    \"+\",\n    \"+\",\n    \"+\",\n    \">\",\n    \"+\",\n    \"<\",\n    \"<\",\n    \"<\",\n    \"<\",\n    \"-\",\n    \"]\",\n    \">\",\n    \"+\",\n    \">\",\n    \"+\",\n    \">\",\n    \"-\",\n    \">\",\n    \">\",\n    \"+\",\n    \"[\",\n    \"<\",\n    \"]\",\n    \"<\",\n    \"-\",\n    \"]\",\n    \">\",\n    \">\",\n    \".\",\n    \">\",\n    \"-\",\n    \"-\",\n    \"-\",\n    \".\",\n    \"+\",\n    \"+\",\n    \"+\",\n    \"+\",\n    \"+\",\n    \"+\",\n    \"+\",\n    \".\",\n    \".\",\n    \"+\",\n    \"+\",\n    \"+\",\n    \".\",\n    \">\",\n    \">\",\n    \".\",\n    \"<\",\n    \"-\",\n    \".\",\n    \"<\",\n    \".\",\n    \"+\",\n    \"+\",\n    \"+\",\n    \".\",\n    \"-\",\n    \"-\",\n    \"-\",\n    \"-\",\n    \"-\",\n    \"-\",\n    \".\",\n    \"-\",\n    \"-\",\n    \"-\",\n    \"-\",\n    \"-\",\n    \"-\",\n    \"-\",\n    \"-\",\n    \".\",\n    \">\",\n    \">\",\n    \"+\",\n    \".\",\n    \">\",\n    \"+\",\n    \"+\",\n    \".\",\n  ],\n};\n\nexport const nestedLoop: Fixture = {\n  raw: \">++++[>,.<->>+++[>+<-]<<]\",\n  parsed: [\n    \">\",\n    \"+\",\n    \"+\",\n    \"+\",\n    \"+\",\n    \"[\",\n    \">\",\n    \",\",\n    \".\",\n    \"<\",\n    \"-\",\n    \">\",\n    \">\",\n    \"+\",\n    \"+\",\n    \"+\",\n    \"[\",\n    \">\",\n    \"+\",\n    \"<\",\n    \"-\",\n    \"]\",\n    \"<\",\n    \"<\",\n    \"]\",\n  ],\n};\n","type TreeNode<V> = {\n  size: number;\n  key: number;\n  value: V;\n  left?: TreeNode<V>;\n  right?: TreeNode<V>;\n};\n\nconst buildTree = <V>(data: V[], start: number, end: number): TreeNode<V> => {\n  if (start > end) throw new Error(\"Cannot parse an empty array\");\n\n  const mid = start + Math.floor((end - start) / 2);\n  const left = start < mid ? buildTree(data, start, mid - 1) : undefined;\n  const right = end > mid ? buildTree(data, mid + 1, end) : undefined;\n  return {\n    size: (left?.size ?? 0) + (right?.size ?? 0) + 1,\n    key: mid,\n    value: data[mid],\n    left: left,\n    right: right,\n  };\n};\n\nconst queryTree = <V>(key: number, node?: TreeNode<V>): V => {\n  if (!!!node) throw new Error(\"List index out of bounds\");\n  if (node.key === key) return node.value;\n\n  return node.key > key ? queryTree(key, node.left) : queryTree(key, node.right);\n};\n\nconst updateTree = <V>(key: number, value: V, node?: TreeNode<V>): TreeNode<V> => {\n  if (!!!node) throw new Error(\"List index out of bounds\");\n  let newNode = Object.assign({}, node);\n\n  if (newNode.key === key) {\n    newNode.value = value;\n    return newNode;\n  }\n\n  if (newNode.key > key) {\n    newNode.left = updateTree(key, value, newNode.left);\n  } else {\n    newNode.right = updateTree(key, value, newNode.right);\n  }\n\n  return newNode;\n};\n\nconst sliceTree = <V>(result: V[], start: number, end: number, node?: TreeNode<V>) => {\n  if (!!!node) throw new Error(\"List index out of range\");\n\n  if (node.left) sliceTree(result, start, end, node.left);\n  if (node.key >= start && node.key < end) result.push(node.value);\n  if (node.right) sliceTree(result, start, end, node.right);\n};\n\nconst createList = <V>(data: V[]): List<V> => new List({ fromArray: true, array: data });\n\nexport class List<V> {\n  root: TreeNode<V>;\n  constructor(data: { fromArray: true; array: V[] } | { fromArray: false; root: TreeNode<V> }) {\n    if (data.fromArray) {\n      this.root = buildTree(data.array, 0, data.array.length - 1);\n    } else {\n      this.root = data.root;\n    }\n  }\n\n  query(key: number): V {\n    return queryTree(key, this.root);\n  }\n\n  /**\n   * Perform an efficient immutable update to the list\n   */\n  update(key: number, value: V): List<V> {\n    const newRoot = updateTree(key, value, this.root);\n    return new List({ fromArray: false, root: newRoot });\n  }\n\n  slice(start: number, end: number): V[] {\n    let result: V[] = [];\n    sliceTree(result, start, end, this.root);\n    return result;\n  }\n\n  size(): number {\n    return this.root.size;\n  }\n}\n\nexport default createList;\n","import { MockStream } from \"../tests/Fixtures\";\nimport { IOStream } from \"./IOStream\";\nimport createList from \"./ImmutableList\";\nimport { ProgramState, brainfuckReducer, isEnded, ParseResult, parse } from \"./Interpreter\";\n\nexport type RunResult = {\n  finalState: ProgramState;\n  numCycles: number;\n  ended: boolean;\n};\n\nconst MEMORY_SIZE = 30000;\nexport const MAX_PROGRAM_CYCLES = 2 << 16;\n\nexport const setupProgram = (\n  parsed: ParseResult,\n  stdin: IOStream,\n  stdout: IOStream\n): ProgramState => ({\n  programCounter: 0,\n  dataPointer: 0,\n  memory: createList(Array(MEMORY_SIZE).fill(0)),\n  program: parsed.program,\n\n  breakpoints: [],\n  blocked: false,\n  blockType: \"none\",\n  loopForward: parsed.loopForward,\n  loopBackward: parsed.loopBackward,\n\n  stdin: stdin,\n  stdout: stdout,\n});\n\nexport const setupTestProgram = (program: string, input: string = \"\") =>\n  setupProgram(parse(program), MockStream(input), MockStream());\n\nexport const runCycles = (state: ProgramState, cycles: number): RunResult => {\n  let cyclesCount = 0;\n  while (!isEnded(state) && cyclesCount++ < cycles) {\n    state = brainfuckReducer(state, { type: \"next\" });\n  }\n  return {\n    finalState: state,\n    numCycles: cyclesCount,\n    ended: isEnded(state),\n  };\n};\n\nexport const run = (state: ProgramState): RunResult => {\n  let cycles = 0;\n  while (!isEnded(state) && ++cycles < MAX_PROGRAM_CYCLES) {\n    state = brainfuckReducer(state, { type: \"next\" });\n    if (state.blocked) break;\n  }\n\n  if (cycles === MAX_PROGRAM_CYCLES && !isEnded(state)) {\n    console.error(\"Time limit exceed\");\n  }\n\n  return {\n    finalState: state,\n    numCycles: cycles,\n    ended: isEnded(state),\n  };\n};\n","export const ASCIIsToString = (n: number[]): string => String.fromCharCode(...n);\nexport const stringToASCIIs = (s: string): number[] => Array.from(s).map((c) => c.charCodeAt(0));\n","import { useCallback, useMemo, useState } from \"react\";\n\nimport { initializeIOStream } from \"../core/IOStream\";\nimport { brainfuckReducer, parse, ParseResult, ProgramState } from \"../core/Interpreter\";\nimport { run, setupProgram } from \"../core/Runner\";\nimport { stringToASCIIs } from \"../core/utils\";\nimport { ReducerAction, ReducerHookReturnType } from \"../types\";\n\nexport type BrainfuckAction =\n  | ReducerAction<\"load\", string>\n  | ReducerAction<\"next\" | \"reset\" | \"run\" | \"continue\">\n  | ReducerAction<\"write\", string>\n  | ReducerAction<\"breakpoint\", number>;\nconst DEFAULT_STREAM_SIZE = 2 << 10;\nconst setup = (parsed: ParseResult) =>\n  setupProgram(\n    parsed,\n    initializeIOStream(DEFAULT_STREAM_SIZE),\n    initializeIOStream(DEFAULT_STREAM_SIZE)\n  );\n\nexport const useBrainfuck = (\n  initialProgram: string = \"\"\n): ReducerHookReturnType<ProgramState, BrainfuckAction> => {\n  const [program, setProgram] = useState(initialProgram);\n  const parsedProgram = useMemo(() => {\n    return parse(program);\n  }, [program]);\n  const [programState, setProgramState] = useState<ProgramState>(setup(parsedProgram));\n\n  const dispatch = useCallback(\n    (action: BrainfuckAction) => {\n      switch (action.type) {\n        case \"load\":\n          setProgram(action.data);\n          break;\n        case \"next\":\n          setProgramState((programState) => brainfuckReducer(programState, { type: \"next\" }));\n          break;\n        case \"run\":\n          setProgramState((programState) => run(programState).finalState);\n          break;\n        case \"reset\":\n          setProgramState(setup(parsedProgram));\n          break;\n        case \"write\":\n          setProgramState((programState) =>\n            brainfuckReducer(programState, { type: \"write\", data: stringToASCIIs(action.data) })\n          );\n          break;\n        case \"breakpoint\":\n          setProgramState((programState) =>\n            brainfuckReducer(programState, { type: \"breakpoint\", data: action.data })\n          );\n          break;\n        case \"continue\":\n          setProgramState((programState) => brainfuckReducer(programState, { type: \"continue\" }));\n          break;\n      }\n    },\n    [setProgram, setProgramState, parsedProgram]\n  );\n\n  return [programState, dispatch];\n};\n","import { useMemo, useState } from \"react\";\n\nimport { BrainfuckAction } from \"../hooks/useBrainfuck\";\n\nimport \"../css/Console.css\";\n\nimport { ProgramState } from \"../core/Interpreter\";\nimport { ASCIIsToString } from \"../core/utils\";\n\nexport type ConsoleProps = {\n  programState: ProgramState;\n  dispatch: (action: BrainfuckAction) => void;\n};\n\nconst Console = ({ programState, dispatch }: ConsoleProps) => {\n  const [inputText, setInputText] = useState(\"\");\n  const ioBuffers = useMemo(\n    () => ({\n      output: ASCIIsToString(programState.stdout.buffer),\n      input: ASCIIsToString(programState.stdin.buffer),\n      inputBuffer: `\"${ASCIIsToString(programState.stdin.readBuffer)}\"`,\n    }),\n    [programState]\n  );\n\n  return (\n    <div>\n      <h2>Output</h2>\n      <div className=\"console\">\n        <div className=\"console-text\">\n          <pre>{ioBuffers.output}</pre>\n        </div>\n      </div>\n      <h2>Input</h2>\n      <div>\n        Last read:{\" \"}\n        {ioBuffers.inputBuffer !== '\"\"' ? (\n          <>\n            <span>{ioBuffers.inputBuffer}</span>&nbsp; at {programState.stdin.readPointer}\n          </>\n        ) : (\n          \"(empty)\"\n        )}\n      </div>\n      <div className=\"console with-input\">\n        <div className=\"console-text\">\n          <pre>{ioBuffers.input}</pre>\n        </div>\n        <div className=\"console-input\">\n          <input\n            placeholder=\"This is the console\"\n            value={inputText}\n            onKeyUp={(e) => {\n              if (e.key === \"Enter\") {\n                dispatch({ type: \"write\", data: inputText });\n                setInputText(\"\");\n              }\n            }}\n            onChange={(e) => setInputText(e.target.value + \"\\n\")}\n          />\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default Console;\n","import { BrainfuckAction } from \"../hooks/useBrainfuck\";\n\nimport \"../css/ControlPanel.css\";\n\nimport { ProgramState, isEnded, isStarted, isPaused } from \"../core/Interpreter\";\nimport { testHelloWorld } from \"../tests/Fixtures\";\n\nexport type ControlPanelProps = {\n  programState: ProgramState;\n  setCode: (code: string) => void;\n  dispatch: (action: BrainfuckAction) => void;\n};\n\nconst ControlPanel = ({ programState, setCode, dispatch }: ControlPanelProps) => {\n  return (\n    <>\n      <h2>\n        Control Panel{\" \"}\n        {programState.program.length === 0 && (\n          <span className=\"note\">(enter any bf program to get started)</span>\n        )}\n      </h2>\n      <p>\n        Status:{\" \"}\n        {!isStarted(programState)\n          ? \"not started\"\n          : isEnded(programState)\n          ? \"ended\"\n          : programState.blocked\n          ? `blocked${\n              programState.blockType === \"breakpoint\"\n                ? \" (breakpoint)\"\n                : programState.blockType === \"io\"\n                ? \" (input required)\"\n                : \"\"\n            }`\n          : \"running\"}\n      </p>\n      <ul className=\"panel\">\n        <li>\n          <button\n            className=\"btn\"\n            onClick={() => {\n              if (isPaused(programState)) dispatch({ type: \"continue\" });\n              dispatch({ type: \"run\" });\n            }}\n            disabled={\n              programState.program.length === 0 ||\n              isEnded(programState) ||\n              (programState.blocked && !isPaused(programState))\n            }\n          >\n            {isStarted(programState) ? \"Continue\" : \"Run\"}\n          </button>\n        </li>\n        <li>\n          <button\n            className=\"btn\"\n            onClick={() => {\n              if (isPaused(programState)) dispatch({ type: \"continue\" });\n              else dispatch({ type: \"next\" });\n            }}\n            disabled={isEnded(programState) || (programState.blocked && !isPaused(programState))}\n          >\n            {!isStarted(programState) ? \"Start\" : \"Step\"}\n          </button>\n        </li>\n        <li>\n          <button\n            className=\"btn\"\n            onClick={() => dispatch({ type: \"reset\" })}\n            disabled={programState.program.length === 0}\n          >\n            Reset\n          </button>\n        </li>\n        <li>\n          <button className=\"btn\" onClick={() => setCode(testHelloWorld.raw)}>\n            Hello World!\n          </button>\n        </li>\n      </ul>\n    </>\n  );\n};\n\nexport default ControlPanel;\n","import CodeEditor from \"@uiw/react-textarea-code-editor\";\n\nexport type EditorProps = {\n  code: string;\n  setCode: (val: string) => void;\n  enabled: boolean;\n};\n\nconst Editor = ({ code, setCode, enabled }: EditorProps) => {\n  return (\n    <>\n      <h2>Editor</h2>\n      <CodeEditor\n        value={code}\n        language=\"brainfuck\"\n        placeholder=\"brainfuck program here\"\n        onChange={(val) => setCode(val.target.value)}\n        padding={10}\n        style={{\n          border: \"1px solid black\",\n          borderRadius: \"var(--border-radius)\",\n        }}\n        disabled={!enabled}\n      />\n    </>\n  );\n};\n\nexport default Editor;\n","import \"../css/UserManual.css\";\n\nconst UserManual = () => {\n  return (\n    <>\n      <h2>User Manual</h2>\n      <p>A BF program has 8 different instructions</p>\n      <table className=\"manual-table\">\n        <tr>\n          <th>Instruction</th>\n          <th>Description</th>\n        </tr>\n        <tr>\n          <td>&gt;</td>\n          <td>Move the data pointer to the right</td>\n        </tr>\n        <tr>\n          <td>&lt;</td>\n          <td>Move the data pointer to the left</td>\n        </tr>\n        <tr>\n          <td>+</td>\n          <td>Increment the current memory cell</td>\n        </tr>\n        <tr>\n          <td>-</td>\n          <td>Decrement the current memory cell</td>\n        </tr>\n        <tr>\n          <td>,</td>\n          <td>Take one input from the stdin</td>\n        </tr>\n        <tr>\n          <td>.</td>\n          <td>Print the current memory (decoded as ASCII)</td>\n        </tr>\n        <tr>\n          <td>[</td>\n          <td>\n            Do nothing when the current memory cell is 0, otherwise jump to corresponding{\" \"}\n            <code>]</code>\n          </td>\n        </tr>\n        <tr>\n          <td>]</td>\n          <td>\n            Do nothing when the current memory cell is 0, otherwise jump to corresponding{\" \"}\n            <code>[</code>\n          </td>\n        </tr>\n      </table>\n      <p>\n        Enter your program in the <span className=\"bordered-text\">Editor</span>. If it is nonempty,\n        you should be able to click on <span className=\"bordered-text\">Run</span> to run it.\n      </p>\n      <p>\n        You can also step through the program one cycle by one cycle after pressing the{\" \"}\n        <span className=\"bordered-text\">Start</span> button.\n      </p>\n      <p>\n        The <span className=\"bordered-text\">Last read</span> section indicates what the program has\n        just read from the user input.\n      </p>\n      <p>\n        To add an breakpoint, just click on the instruction to pause at in the parsed program block.\n      </p>\n    </>\n  );\n};\n\nexport default UserManual;\n","import { useMemo } from \"react\";\n\nimport { BrainfuckAction } from \"../hooks/useBrainfuck\";\n\nimport \"../css/Visualization.css\";\n\nimport { isStarted, ProgramState } from \"../core/Interpreter\";\n\nexport type VisualizationProps = {\n  programState: ProgramState;\n  dispatch: (action: BrainfuckAction) => void;\n};\n\nconst Visualization = ({ programState, dispatch }: VisualizationProps) => {\n  const isCurrentPc = (pc: number) =>\n    (!programState.blocked &&\n      (pc === programState.programCounter - 1 ||\n        (pc === 0 && programState.programCounter === 0))) ||\n    (programState.blocked && pc === programState.programCounter);\n  const breakpoints = useMemo(() => {\n    let currentBreakpointIndex = 0;\n    return programState.program.map((_, index) => {\n      if (index === programState.breakpoints[currentBreakpointIndex]) {\n        currentBreakpointIndex++;\n        return true;\n      }\n      return false;\n    });\n  }, [programState.program, programState.breakpoints]);\n\n  return (\n    <>\n      <h2>Visualization</h2>\n      <div className=\"visualization\">\n        <div className=\"program-field\">\n          {programState.program.map((instruction, index) => (\n            <span\n              key={index}\n              className={(isStarted(programState) && isCurrentPc(index)\n                ? \"highlighted\"\n                : \"\"\n              ).concat(breakpoints[index] ? \" breakpoint\" : \"\")}\n              onClick={() => dispatch({ type: \"breakpoint\", data: index })}\n            >\n              {instruction}\n            </span>\n          ))}\n          <p>parsed program</p>\n        </div>\n        <div>\n          <p>\n            program counter: {programState.programCounter}\n            {programState.blocked ? \" (waiting for input)\" : \"\"}\n          </p>\n          <p>data pointer: {programState.dataPointer}</p>\n          <p>current data: {programState.memory.query(programState.dataPointer)}</p>\n        </div>\n      </div>\n    </>\n  );\n};\n\nexport default Visualization;\n","import { useEffect, useState } from \"react\";\n\nimport { useBrainfuck } from \"../hooks/useBrainfuck\";\n\nimport \"../css/App.css\";\n\nimport Console from \"./Console\";\nimport ControlPanel from \"./ControlPanel\";\nimport Editor from \"./Editor\";\nimport UserManual from \"./UserManual\";\nimport Visualization from \"./Visualization\";\n\nfunction App() {\n  const [code, setCode] = useState(\"\");\n  const [brainfuck, dispatch] = useBrainfuck(code);\n  const [editorEnabled] = useState(true);\n\n  useEffect(() => {\n    dispatch({ type: \"load\", data: code });\n    dispatch({ type: \"reset\" });\n  }, [code, dispatch]);\n\n  return (\n    <div className=\"App\">\n      <main className=\"App-main\">\n        <div>\n          <h1 id=\"center\">react-brainfucked</h1>\n        </div>\n        <div>\n          <Editor code={code} setCode={setCode} enabled={editorEnabled} />\n          <Visualization programState={brainfuck} dispatch={dispatch} />\n          <ControlPanel programState={brainfuck} setCode={setCode} dispatch={dispatch} />\n          <Console programState={brainfuck} dispatch={dispatch} />\n          <UserManual />\n        </div>\n      </main>\n    </div>\n  );\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\n\nimport App from \"./components/App\";\n\nimport \"./css/index.css\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}