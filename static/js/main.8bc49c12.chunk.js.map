{"version":3,"sources":["core/IOStream.ts","core/Interpreter.ts","tests/Fixtures.tsx","core/ImmutableList.ts","core/Runner.ts","core/utils.ts","hooks/useStream.ts","hooks/useBrainfuck.ts","components/Console.tsx","components/ControlPanel.tsx","components/Editor.tsx","components/UserManual.tsx","components/Memory.tsx","components/Visualization.tsx","components/App.tsx","index.tsx"],"names":["copyStream","stream","buffer","slice","readBuffer","initializeIOStream","size","pointer","readPointer","pendingSize","ioReducer","action","type","newStream","length","read","data","concat","Math","max","write","index","seek","instructionSet","Set","copyState","state","breakpoints","readMemory","memory","query","dataPointer","writeMemory","update","fetchInstruction","program","programCounter","isEnded","isStarted","blocked","isPaused","blockType","parse","output","startsWith","count","loopForward","ImmutableMap","loopBackward","split","filter","s","has","i","leftBrackets","Map","push","loopBeginning","pop","undefined","set","console","error","next","continuing","newState","binarySearch","instruction","overridePc","stdin","Error","stdout","target","get","brainfuckReducer","writeToStdin","unblockBreakpoint","breakpoint","ioStreams","input","refreshIO","testHelloWorld","buildTree","start","end","mid","floor","left","right","key","value","queryTree","node","updateTree","newNode","Object","assign","sliceTree","result","List","root","fromArray","this","array","createList","MAX_PROGRAM_CYCLES","setupProgram","parsed","Array","fill","run","cycles","finalState","numCycles","ended","ASCIIsToString","n","String","fromCharCode","stringToASCIIs","from","map","c","charCodeAt","useStream","useState","setStream","dispatch","useCallback","DEFAULT_STREAM_SIZE","setup","Console","programState","inputText","setInputText","ioBuffers","useMemo","inputBuffer","className","placeholder","onKeyUp","e","onChange","ControlPanel","setCode","onClick","disabled","Editor","code","enabled","language","val","padding","style","border","borderRadius","UserManual","MemoryBlock","highlighted","toString","JSON","stringify","Memory","memoryLower","memoryUpper","memIndex","Visualization","memoryDisplayCount","min","currentBreakpointIndex","_","pc","getMemoryDisplayCount","width","App","initialProgram","setProgram","parsedProgram","inputStream","inputStreamDispatch","outputStream","outputStreamDispatch","setProgramState","useEffect","useBrainfuck","brainfuck","editorEnabled","window","innerWidth","setMemoryDisplayCount","handleResize","addEventListener","removeEventListener","id","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.8bc49c12.chunk.js","sourcesContent":["import { ReducerAction } from \"../types\";\n\nexport type IOAction =\n  | ReducerAction<\"read\" | \"seek\", number>\n  | ReducerAction<\"write\", number | number[]>;\nexport type IOStream = {\n  buffer: number[];\n  size: number;\n  pointer: number;\n  // The buffer for the last read\n  readPointer: number;\n  readBuffer: number[];\n  pendingSize: number;\n};\n\nexport type ReadOutput = [stream: IOStream, data: number];\n\nconst copyStream = (stream: IOStream) => ({\n  ...stream,\n  buffer: stream.buffer.slice(0),\n  readBuffer: stream.readBuffer.slice(0),\n});\n\n/**\n * When the stream is blocked (pendingSize > 0), no data will be read into the buffer\n */\nexport const read = (stream: IOStream, size: number): IOStream => {\n  let newStream = copyStream(stream);\n  if (newStream.pendingSize > 0 || newStream.buffer.length <= newStream.readPointer) {\n    newStream.pendingSize += size;\n    return newStream;\n  }\n\n  // Read `size` of bytes from the buffer\n  newStream.readBuffer = newStream.buffer.slice(\n    newStream.readPointer,\n    newStream.readPointer + size\n  );\n\n  newStream.readPointer = newStream.readPointer + newStream.readBuffer.length;\n  if (newStream.readBuffer.length < size) {\n    // We haven't read enough bytes, expect more inputs\n    newStream.pendingSize += size - newStream.readBuffer.length;\n  }\n\n  return newStream;\n};\n\nexport const write = (stream: IOStream, data: number | number[]): IOStream => {\n  if (typeof data == \"number\") data = [data];\n\n  let newStream = copyStream(stream);\n  newStream.buffer = newStream.buffer.slice(0, newStream.pointer).concat(data);\n  newStream.pointer += data.length;\n\n  if (newStream.pendingSize > 0) {\n    // Prevent pendingSize from underflowing\n    newStream.pendingSize = Math.max(newStream.pendingSize - data.length, 0);\n  }\n\n  return newStream;\n};\n\nconst seek = (stream: IOStream, index: number): IOStream => {\n  let newStream = copyStream(stream);\n  newStream.pointer = index;\n  newStream.readPointer = index;\n  return newStream;\n};\n\nexport const initializeIOStream = (size: number): IOStream => ({\n  buffer: [],\n  size: size,\n  pointer: 0,\n  readPointer: 0,\n  readBuffer: [],\n  pendingSize: 0,\n});\n\nexport const ioReducer = (stream: IOStream, action: IOAction): IOStream => {\n  switch (action.type) {\n    case \"read\":\n      return read(stream, action.data);\n    case \"write\":\n      return write(stream, action.data);\n    case \"seek\":\n      return seek(stream, action.data);\n  }\n};\n","import binarySearch from \"binarysearch\";\n// External library for laziness (and performance)\nimport { Map as ImmutableMap } from \"immutable\";\n\nimport { ReducerAction } from \"../types\";\nimport { ioReducer, IOStream } from \"./IOStream\";\n// Homemade Immutable List just for fun\nimport { List } from \"./ImmutableList\";\n\nexport type IOStreams = {\n  input: IOStream;\n  output: IOStream;\n};\nexport type BrainfuckCoreAction =\n  | ReducerAction<\"next\" | \"continue\">\n  | ReducerAction<\"breakpoint\", number>\n  | ReducerAction<\"write\", number[]>\n  | ReducerAction<\"refresh-io\", IOStreams>;\nconst instructionSet = new Set([\"<\", \">\", \",\", \".\", \"[\", \"]\", \"+\", \"-\"]);\nexport type Instruction = \"<\" | \">\" | \",\" | \".\" | \"[\" | \"]\" | \"+\" | \"-\";\nexport type BlockType = \"none\" | \"io\" | \"breakpoint\";\nexport type ParseResult = {\n  program: Instruction[];\n  loopForward: ImmutableMap<number, number>;\n  loopBackward: ImmutableMap<number, number>;\n};\n\nexport type ProgramState = {\n  programCounter: number;\n  dataPointer: number;\n  memory: List<number>;\n  program: Instruction[];\n\n  breakpoints: number[];\n  loopForward: ImmutableMap<number, number>;\n  loopBackward: ImmutableMap<number, number>;\n  blocked: boolean;\n  blockType: BlockType;\n\n  stdin: IOStream;\n  stdout: IOStream;\n};\n\nconst copyState = (state: ProgramState): ProgramState => ({\n  ...state,\n  // TODO: Implement immutable dynamic list\n  breakpoints: state.breakpoints.slice(0),\n});\n\nconst readMemory = (state: ProgramState) => state.memory.query(state.dataPointer);\nconst writeMemory = (state: ProgramState, data: number) =>\n  (state.memory = state.memory.update(state.dataPointer, data));\nconst fetchInstruction = (state: ProgramState): Instruction => state.program[state.programCounter];\n\nexport const isEnded = (state: ProgramState) => state.programCounter === state.program.length;\nexport const isStarted = (state: ProgramState) => state.programCounter > 0 || state.blocked;\nexport const isPaused = (state: ProgramState) => state.blockType === \"breakpoint\" && state.blocked;\n\n/**\n * Parse out the initial loop and ignore non-instruction characters\n */\nexport const parse = (program: string): ParseResult => {\n  let output: Instruction[] = [];\n  if (program.startsWith(\"[\")) {\n    let count = 1,\n      index = 1;\n    while (count > 0) {\n      if (program[index] === \"[\") {\n        count++;\n      }\n      if (program[index] === \"]\") {\n        count--;\n      }\n      if (index > 30000) {\n        return {\n          program: [],\n          loopForward: ImmutableMap(),\n          loopBackward: ImmutableMap(),\n        };\n      }\n      index++;\n    }\n    program = program.slice(index + 1);\n  }\n\n  output = program.split(\"\").filter((s) => instructionSet.has(s)) as any;\n\n  let i = 0;\n  let leftBrackets: number[] = [];\n  let loopForward = new Map<number, number>(),\n    loopBackward = new Map<number, number>();\n\n  for (; i < output.length; i++) {\n    if (output[i] === \"[\") {\n      leftBrackets.push(i);\n    } else if (output[i] === \"]\") {\n      let loopBeginning = leftBrackets.pop();\n      if (loopBeginning === undefined) break;\n\n      loopForward.set(loopBeginning, i);\n      loopBackward.set(i, loopBeginning);\n    }\n  }\n\n  if (leftBrackets.length > 0 || i < output.length) console.error(\"Unbalanced loops\");\n\n  return {\n    program: output,\n    loopForward: ImmutableMap(loopForward),\n    loopBackward: ImmutableMap(loopBackward),\n  };\n};\n\nconst next = (state: ProgramState, continuing: boolean = false): ProgramState => {\n  if (isEnded(state) || state.blocked) return state;\n\n  let newState = copyState(state);\n\n  if (binarySearch(newState.breakpoints, newState.programCounter) >= 0 && !continuing) {\n    // Breakpoint is triggered, it has a higher priority than the io block\n    newState.blocked = true;\n    newState.blockType = \"breakpoint\";\n    return newState;\n  }\n\n  const instruction = fetchInstruction(newState);\n  let overridePc = false;\n\n  switch (instruction) {\n    case \">\":\n      newState.dataPointer++;\n      break;\n    case \"<\":\n      newState.dataPointer--;\n      break;\n    case \"+\":\n      writeMemory(newState, readMemory(newState) + (1 % 256));\n      break;\n    case \"-\":\n      writeMemory(newState, (readMemory(newState) - 1 + 256) % 256);\n      break;\n    case \",\":\n      newState.stdin = ioReducer(newState.stdin, { type: \"read\", data: 1 });\n      if (newState.stdin.pendingSize > 0) {\n        // The stream is blocked, do not proceed\n        // The only way to resolve a blocked stream is to dispatch `write`\n        newState.blocked = true;\n        newState.blockType = \"io\";\n        return newState;\n      }\n      writeMemory(newState, newState.stdin.readBuffer[0]);\n      if (newState.stdin.readBuffer[0] === undefined)\n        throw new Error(`invalid write ${newState.stdin}`);\n      break;\n    case \".\":\n      newState.stdout = ioReducer(newState.stdout, { type: \"write\", data: readMemory(newState) });\n      break;\n    case \"[\":\n      if (readMemory(newState) === 0) {\n        // Skip the entire loop body until we reaches the corresponding ]\n        const target = newState.loopForward.get(newState.programCounter);\n        if (target === undefined) throw new Error(\"Cannot find the corresponding ]\");\n        newState.programCounter = target + 1;\n        overridePc = true;\n      }\n      break;\n    case \"]\":\n      if (readMemory(newState) !== 0) {\n        // Skip the entire loop body until we reaches the corresponding ]\n        const target = newState.loopBackward.get(newState.programCounter);\n        if (target === undefined) throw new Error(\"Cannot find the corresponding ]\");\n        newState.programCounter = target + 1;\n        overridePc = true;\n      }\n      break;\n  }\n\n  if (!overridePc) newState.programCounter++;\n\n  return newState;\n};\n\n/**\n * Write directly to the standard input stream\n */\nconst writeToStdin = (state: ProgramState, data: number[]) => {\n  let newState = copyState(state);\n  newState.stdin = ioReducer(newState.stdin, { type: \"write\", data: data });\n  if (newState.stdin.pendingSize === 0 && newState.blockType === \"io\") {\n    newState.blocked = false;\n    newState.blockType = \"none\";\n  }\n\n  return newState;\n};\n\nconst unblockBreakpoint = (state: ProgramState) => {\n  let newState = copyState(state);\n  if (newState.blocked && newState.blockType === \"breakpoint\") {\n    newState.blocked = false;\n    newState.blockType = \"none\";\n  }\n\n  return newState;\n};\n\nconst breakpoint = (state: ProgramState, breakpoint: number) => {\n  let newState = copyState(state);\n  for (let i = 0; i <= newState.breakpoints.length; i++) {\n    if (newState.breakpoints[i] === breakpoint) {\n      newState.breakpoints = newState.breakpoints\n        .slice(0, i)\n        .concat(newState.breakpoints.slice(i + 1, newState.breakpoints.length));\n      return newState;\n    }\n\n    if (i === newState.breakpoints.length || newState.breakpoints[i] > breakpoint) {\n      newState.breakpoints = newState.breakpoints\n        .slice(0, i)\n        .concat([breakpoint], newState.breakpoints.slice(i, newState.breakpoints.length));\n      return newState;\n    }\n  }\n\n  return newState;\n};\n\nconst refreshIO = (state: ProgramState, ioStreams: IOStreams) => {\n  let newState = copyState(state);\n  state.stdin = ioStreams.input;\n  state.stdout = ioStreams.output;\n  return newState;\n}\n\nexport const brainfuckReducer = (\n  state: ProgramState,\n  action: BrainfuckCoreAction\n): ProgramState => {\n  switch (action.type) {\n    case \"next\":\n      return next(state);\n    case \"write\":\n      return writeToStdin(state, action.data);\n    case \"continue\":\n      return next(unblockBreakpoint(state), true);\n    case \"breakpoint\":\n      return breakpoint(state, action.data);\n    case \"refresh-io\":\n      return refreshIO(state, action.data);\n  }\n};\n","import { IOStream } from \"../core/IOStream\";\nimport { Instruction } from \"../core/Interpreter\";\n\nexport const MockStream = (content: string = \"\"): IOStream => ({\n  buffer: Array.from(content).map((c) => c.charCodeAt(0)),\n  size: Infinity,\n  pointer: 0,\n  readPointer: 0,\n  readBuffer: [],\n  pendingSize: 0,\n});\n\nexport type Fixture = {\n  raw: string;\n  parsed: Instruction[];\n};\n\nexport const testHelloWorld: Fixture = {\n  raw: `[ This program prints \"Hello World!\" and a newline to the screen, its\nlength is 106 active command characters. [It is not the shortest.]\n\nThis loop is an \"initial comment loop\", a simple way of adding a comment\nto a BF program such that you don't have to worry about any command\ncharacters. Any \".\", \",\", \"+\", \"-\", \"<\" and \">\" characters are simply\nignored, the \"[\" and \"]\" characters just have to be balanced. This\nloop and the commands it contains are ignored because the current cell\ndefaults to a value of 0; the 0 value causes this loop to be skipped.\n]\n++++++++               Set Cell #0 to 8\n[\n  >++++               Add 4 to Cell #1; this will always set Cell #1 to 4\n  [                   as the cell will be cleared by the loop\n      >++             Add 2 to Cell #2\n      >+++            Add 3 to Cell #3\n      >+++            Add 3 to Cell #4\n      >+              Add 1 to Cell #5\n      <<<<-           Decrement the loop counter in Cell #1\n  ]                   Loop until Cell #1 is zero; number of iterations is 4\n  >+                  Add 1 to Cell #2\n  >+                  Add 1 to Cell #3\n  >-                  Subtract 1 from Cell #4\n  >>+                 Add 1 to Cell #6\n  [<]                 Move back to the first zero cell you find; this will\n                      be Cell #1 which was cleared by the previous loop\n  <-                  Decrement the loop Counter in Cell #0\n]                       Loop until Cell #0 is zero; number of iterations is 8\n\nThe result of this is:\nCell no :   0   1   2   3   4   5   6\nContents:   0   0  72 104  88  32   8\nPointer :   ^\n\n>>.                     Cell #2 has value 72 which is 'H'\n>---.                   Subtract 3 from Cell #3 to get 101 which is 'e'\n+++++++..+++.           Likewise for 'llo' from Cell #3\n>>.                     Cell #5 is 32 for the space\n<-.                     Subtract 1 from Cell #4 for 87 to give a 'W'\n<.                      Cell #3 was set to 'o' from the end of 'Hello'\n+++.------.--------.    Cell #3 for 'rl' and 'd'\n>>+.                    Add 1 to Cell #5 gives us an exclamation point\n>++.                    And finally a newline from Cell #6`,\n  parsed: [\n    \"+\",\n    \"+\",\n    \"+\",\n    \"+\",\n    \"+\",\n    \"+\",\n    \"+\",\n    \"+\",\n    \"[\",\n    \">\",\n    \"+\",\n    \"+\",\n    \"+\",\n    \"+\",\n    \"[\",\n    \">\",\n    \"+\",\n    \"+\",\n    \">\",\n    \"+\",\n    \"+\",\n    \"+\",\n    \">\",\n    \"+\",\n    \"+\",\n    \"+\",\n    \">\",\n    \"+\",\n    \"<\",\n    \"<\",\n    \"<\",\n    \"<\",\n    \"-\",\n    \"]\",\n    \">\",\n    \"+\",\n    \">\",\n    \"+\",\n    \">\",\n    \"-\",\n    \">\",\n    \">\",\n    \"+\",\n    \"[\",\n    \"<\",\n    \"]\",\n    \"<\",\n    \"-\",\n    \"]\",\n    \">\",\n    \">\",\n    \".\",\n    \">\",\n    \"-\",\n    \"-\",\n    \"-\",\n    \".\",\n    \"+\",\n    \"+\",\n    \"+\",\n    \"+\",\n    \"+\",\n    \"+\",\n    \"+\",\n    \".\",\n    \".\",\n    \"+\",\n    \"+\",\n    \"+\",\n    \".\",\n    \">\",\n    \">\",\n    \".\",\n    \"<\",\n    \"-\",\n    \".\",\n    \"<\",\n    \".\",\n    \"+\",\n    \"+\",\n    \"+\",\n    \".\",\n    \"-\",\n    \"-\",\n    \"-\",\n    \"-\",\n    \"-\",\n    \"-\",\n    \".\",\n    \"-\",\n    \"-\",\n    \"-\",\n    \"-\",\n    \"-\",\n    \"-\",\n    \"-\",\n    \"-\",\n    \".\",\n    \">\",\n    \">\",\n    \"+\",\n    \".\",\n    \">\",\n    \"+\",\n    \"+\",\n    \".\",\n  ],\n};\n\nexport const nestedLoop: Fixture = {\n  raw: \">++++[>,.<->>+++[>+<-]<<]\",\n  parsed: [\n    \">\",\n    \"+\",\n    \"+\",\n    \"+\",\n    \"+\",\n    \"[\",\n    \">\",\n    \",\",\n    \".\",\n    \"<\",\n    \"-\",\n    \">\",\n    \">\",\n    \"+\",\n    \"+\",\n    \"+\",\n    \"[\",\n    \">\",\n    \"+\",\n    \"<\",\n    \"-\",\n    \"]\",\n    \"<\",\n    \"<\",\n    \"]\",\n  ],\n};\n","type TreeNode<V> = {\n  size: number;\n  key: number;\n  value: V;\n  left?: TreeNode<V>;\n  right?: TreeNode<V>;\n};\n\nconst buildTree = <V>(data: V[], start: number, end: number): TreeNode<V> => {\n  if (start > end) throw new Error(\"Cannot parse an empty array\");\n\n  const mid = start + Math.floor((end - start) / 2);\n  const left = start < mid ? buildTree(data, start, mid - 1) : undefined;\n  const right = end > mid ? buildTree(data, mid + 1, end) : undefined;\n  return {\n    size: (left?.size ?? 0) + (right?.size ?? 0) + 1,\n    key: mid,\n    value: data[mid],\n    left: left,\n    right: right,\n  };\n};\n\nconst queryTree = <V>(key: number, node?: TreeNode<V>): V => {\n  if (!!!node) throw new Error(\"List index out of bounds\");\n  if (node.key === key) return node.value;\n\n  return node.key > key ? queryTree(key, node.left) : queryTree(key, node.right);\n};\n\nconst updateTree = <V>(key: number, value: V, node?: TreeNode<V>): TreeNode<V> => {\n  if (!!!node) throw new Error(\"List index out of bounds\");\n  let newNode = Object.assign({}, node);\n\n  if (newNode.key === key) {\n    newNode.value = value;\n    return newNode;\n  }\n\n  if (newNode.key > key) {\n    newNode.left = updateTree(key, value, newNode.left);\n  } else {\n    newNode.right = updateTree(key, value, newNode.right);\n  }\n\n  return newNode;\n};\n\nconst sliceTree = <V>(result: V[], start: number, end: number, node?: TreeNode<V>) => {\n  if (!!!node) throw new Error(\"List index out of range\");\n\n  if (node.left) sliceTree(result, start, end, node.left);\n  if (node.key >= start && node.key < end) result.push(node.value);\n  if (node.right) sliceTree(result, start, end, node.right);\n};\n\nconst createList = <V>(data: V[]): List<V> => new List({ fromArray: true, array: data });\n\nexport class List<V> {\n  root: TreeNode<V>;\n  constructor(data: { fromArray: true; array: V[] } | { fromArray: false; root: TreeNode<V> }) {\n    if (data.fromArray) {\n      this.root = buildTree(data.array, 0, data.array.length - 1);\n    } else {\n      this.root = data.root;\n    }\n  }\n\n  query(key: number): V {\n    return queryTree(key, this.root);\n  }\n\n  /**\n   * Perform an efficient immutable update to the list\n   */\n  update(key: number, value: V): List<V> {\n    const newRoot = updateTree(key, value, this.root);\n    return new List({ fromArray: false, root: newRoot });\n  }\n\n  slice(start: number, end: number): V[] {\n    let result: V[] = [];\n    sliceTree(result, start, end, this.root);\n    return result;\n  }\n\n  size(): number {\n    return this.root.size;\n  }\n}\n\nexport default createList;\n","import { MockStream } from \"../tests/Fixtures\";\nimport { IOStream } from \"./IOStream\";\nimport createList from \"./ImmutableList\";\nimport { ProgramState, brainfuckReducer, isEnded, ParseResult, parse } from \"./Interpreter\";\n\nexport type RunResult = {\n  finalState: ProgramState;\n  numCycles: number;\n  ended: boolean;\n};\n\nconst MEMORY_SIZE = 30000;\nexport const MAX_PROGRAM_CYCLES = 2 << 16;\n\nexport const setupProgram = (\n  parsed: ParseResult,\n  stdin: IOStream,\n  stdout: IOStream\n): ProgramState => ({\n  programCounter: 0,\n  dataPointer: 0,\n  memory: createList(Array(MEMORY_SIZE).fill(0)),\n  program: parsed.program,\n\n  breakpoints: [],\n  blocked: false,\n  blockType: \"none\",\n  loopForward: parsed.loopForward,\n  loopBackward: parsed.loopBackward,\n\n  stdin: stdin,\n  stdout: stdout,\n});\n\nexport const setupTestProgram = (program: string, input: string = \"\") =>\n  setupProgram(parse(program), MockStream(input), MockStream());\n\nexport const runCycles = (state: ProgramState, cycles: number): RunResult => {\n  let cyclesCount = 0;\n  while (!isEnded(state) && cyclesCount++ < cycles) {\n    state = brainfuckReducer(state, { type: \"next\" });\n  }\n  return {\n    finalState: state,\n    numCycles: cyclesCount,\n    ended: isEnded(state),\n  };\n};\n\nexport const run = (state: ProgramState): RunResult => {\n  let cycles = 0;\n  while (!isEnded(state) && ++cycles < MAX_PROGRAM_CYCLES) {\n    state = brainfuckReducer(state, { type: \"next\" });\n    if (state.blocked) break;\n  }\n\n  if (cycles === MAX_PROGRAM_CYCLES && !isEnded(state)) {\n    console.error(\"Time limit exceed\");\n  }\n\n  return {\n    finalState: state,\n    numCycles: cycles,\n    ended: isEnded(state),\n  };\n};\n","export const ASCIIsToString = (n: number[]): string => String.fromCharCode(...n);\nexport const stringToASCIIs = (s: string): number[] => Array.from(s).map((c) => c.charCodeAt(0));\n","import { useCallback, useState } from \"react\";\n\nimport { initializeIOStream, IOAction, ioReducer, IOStream } from \"../core/IOStream\";\nimport { ReducerAction, ReducerHookReturnType } from \"../types\";\n\nexport type StreamAction = IOAction | ReducerAction<\"reset\">;\n\nexport const useStream = (size: number): ReducerHookReturnType<IOStream, StreamAction> => {\n  const [stream, setStream] = useState<IOStream>(initializeIOStream(size));\n\n  const dispatch = useCallback((action: StreamAction) => {\n    if(action.type === \"reset\") {\n      setStream(initializeIOStream(size));\n      return;\n    }\n\n    setStream(stream => ioReducer(stream, action));\n  }, [setStream, size]);\n\n  return [stream, dispatch];\n};\n","import { useCallback, useEffect, useMemo, useState } from \"react\";\n\nimport { IOStream } from \"../core/IOStream\";\nimport { brainfuckReducer, parse, ParseResult, ProgramState } from \"../core/Interpreter\";\nimport { run, setupProgram } from \"../core/Runner\";\nimport { stringToASCIIs } from \"../core/utils\";\nimport { ReducerAction, ReducerHookReturnType } from \"../types\";\nimport { useStream } from \"./useStream\";\n\nexport type BrainfuckAction =\n  | ReducerAction<\"load\", string>\n  | ReducerAction<\"next\" | \"reset\" | \"reset-io\" | \"run\" | \"continue\">\n  | ReducerAction<\"write\", string>\n  | ReducerAction<\"breakpoint\", number>;\nconst DEFAULT_STREAM_SIZE = 2 << 10;\nconst setup = (parsed: ParseResult, input: IOStream, output: IOStream) =>\n  setupProgram(\n    parsed,\n    input,\n    output\n  );\n\nexport const useBrainfuck = (\n  initialProgram: string = \"\"\n): ReducerHookReturnType<ProgramState, BrainfuckAction> => {\n  const [program, setProgram] = useState(initialProgram);\n  const parsedProgram = useMemo(() => {\n    return parse(program);\n  }, [program]);\n  const [inputStream, inputStreamDispatch] = useStream(DEFAULT_STREAM_SIZE);\n  const [outputStream, outputStreamDispatch] = useStream(DEFAULT_STREAM_SIZE);\n  const [programState, setProgramState] = useState<ProgramState>(setup(parsedProgram, inputStream, outputStream));\n\n  useEffect(() => {\n    setProgramState((programState) => brainfuckReducer(programState, {type: \"refresh-io\", data: {input: inputStream, output: outputStream}}))\n  }, [inputStream, outputStream]);\n\n  const dispatch = useCallback(\n    (action: BrainfuckAction) => {\n      switch (action.type) {\n        case \"load\":\n          setProgram(action.data);\n          break;\n        case \"next\":\n          setProgramState((programState) => brainfuckReducer(programState, { type: \"next\" }));\n          break;\n        case \"run\":\n          setProgramState((programState) => run(programState).finalState);\n          break;\n        case \"reset\":\n          setProgramState((programState) => setup(parsedProgram, programState.stdin, programState.stdout));\n          break;\n        case \"reset-io\":\n          inputStreamDispatch({type: \"reset\"});\n          outputStreamDispatch({type: \"reset\"});\n          break;\n        case \"write\":\n          setProgramState((programState) =>\n            brainfuckReducer(programState, { type: \"write\", data: stringToASCIIs(action.data) })\n          );\n          break;\n        case \"breakpoint\":\n          setProgramState((programState) =>\n            brainfuckReducer(programState, { type: \"breakpoint\", data: action.data })\n          );\n          break;\n        case \"continue\":\n          setProgramState((programState) => brainfuckReducer(programState, { type: \"continue\" }));\n          break;\n      }\n    },\n    [setProgram, setProgramState, parsedProgram, inputStreamDispatch, outputStreamDispatch]\n  );\n\n  return [programState, dispatch];\n};\n","import { useMemo, useState } from \"react\";\n\nimport { BrainfuckAction } from \"../hooks/useBrainfuck\";\n\nimport \"../css/Console.css\";\n\nimport { ProgramState } from \"../core/Interpreter\";\nimport { ASCIIsToString } from \"../core/utils\";\n\nexport type ConsoleProps = {\n  programState: ProgramState;\n  dispatch: (action: BrainfuckAction) => void;\n};\n\nconst Console = ({ programState, dispatch }: ConsoleProps) => {\n  const [inputText, setInputText] = useState(\"\");\n  const ioBuffers = useMemo(\n    () => ({\n      output: ASCIIsToString(programState.stdout.buffer),\n      input: ASCIIsToString(programState.stdin.buffer),\n      inputBuffer: `\"${ASCIIsToString(programState.stdin.readBuffer)}\"`,\n    }),\n    [programState]\n  );\n\n  return (\n    <div>\n      <h2>Output</h2>\n      <div className=\"console\">\n        <div className=\"console-text\">\n          <pre>{ioBuffers.output}</pre>\n        </div>\n      </div>\n      <h2>Input</h2>\n      <div>\n        Last read:{\" \"}\n        {ioBuffers.inputBuffer !== '\"\"' ? (\n          <>\n            <span>{ioBuffers.inputBuffer}</span>&nbsp; at {programState.stdin.readPointer}\n          </>\n        ) : (\n          \"(empty)\"\n        )}\n      </div>\n      <div className=\"console with-input\">\n        <div className=\"console-text\">\n          <pre>{ioBuffers.input}</pre>\n        </div>\n        <div className=\"console-input\">\n          <input\n            placeholder=\"This is the console\"\n            value={inputText}\n            onKeyUp={(e) => {\n              if (e.key === \"Enter\") {\n                dispatch({ type: \"write\", data: inputText });\n                setInputText(\"\");\n              }\n            }}\n            onChange={(e) => setInputText(e.target.value + \"\\n\")}\n          />\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default Console;\n","import { BrainfuckAction } from \"../hooks/useBrainfuck\";\n\nimport \"../css/ControlPanel.css\";\n\nimport { ProgramState, isEnded, isStarted, isPaused } from \"../core/Interpreter\";\nimport { testHelloWorld } from \"../tests/Fixtures\";\n\nexport type ControlPanelProps = {\n  programState: ProgramState;\n  setCode: (code: string) => void;\n  dispatch: (action: BrainfuckAction) => void;\n};\n\nconst ControlPanel = ({ programState, setCode, dispatch }: ControlPanelProps) => {\n  return (\n    <div>\n      <h2>\n        Control Panel{\" \"}\n        {programState.program.length === 0 && (\n          <span className=\"note\">(enter any bf program to get started)</span>\n        )}\n      </h2>\n      <p>\n        Status:{\" \"}\n        {!isStarted(programState)\n          ? \"not started\"\n          : isEnded(programState)\n          ? \"ended\"\n          : programState.blocked\n          ? `blocked${\n              programState.blockType === \"breakpoint\"\n                ? \" (breakpoint)\"\n                : programState.blockType === \"io\"\n                ? \" (input required)\"\n                : \"\"\n            }`\n          : \"running\"}\n      </p>\n      <ul className=\"panel\">\n        <li>\n          <button\n            className=\"btn\"\n            onClick={() => {\n              if (isPaused(programState)) dispatch({ type: \"continue\" });\n              dispatch({ type: \"run\" });\n            }}\n            disabled={\n              programState.program.length === 0 ||\n              isEnded(programState) ||\n              (programState.blocked && !isPaused(programState))\n            }\n          >\n            {isStarted(programState) ? \"Continue\" : \"Run\"}\n          </button>\n        </li>\n        <li>\n          <button\n            className=\"btn\"\n            onClick={() => {\n              if (isPaused(programState)) dispatch({ type: \"continue\" });\n              else dispatch({ type: \"next\" });\n            }}\n            disabled={isEnded(programState) || (programState.blocked && !isPaused(programState))}\n          >\n            {!isStarted(programState) ? \"Start\" : \"Step\"}\n          </button>\n        </li>\n        <li>\n          <button\n            className=\"btn\"\n            onClick={() => {\n              if(!isStarted(programState)){\n                dispatch({type:\"reset-io\"});\n              }\n              dispatch({ type: \"reset\" });\n            }}\n            disabled={programState.program.length === 0}\n          >\n            Reset {!isStarted(programState) && (programState.stdin.pointer > 0 || programState.stdout.pointer > 0) ? \"IO\" : \"\"}\n          </button>\n        </li>\n        <li>\n          <button className=\"btn\" onClick={() => setCode(testHelloWorld.raw)}>\n            Hello World!\n          </button>\n        </li>\n      </ul>\n    </div>\n  );\n};\n\nexport default ControlPanel;\n","import CodeEditor from \"@uiw/react-textarea-code-editor\";\n\nexport type EditorProps = {\n  code: string;\n  setCode: (val: string) => void;\n  enabled: boolean;\n};\n\nconst Editor = ({ code, setCode, enabled }: EditorProps) => {\n  return (\n    <div>\n      <h2>Editor</h2>\n      <CodeEditor\n        value={code}\n        language=\"brainfuck\"\n        placeholder=\"brainfuck program here\"\n        onChange={(val) => setCode(val.target.value)}\n        padding={10}\n        style={{\n          border: \"1px solid black\",\n          borderRadius: \"var(--border-radius)\",\n        }}\n        disabled={!enabled}\n      />\n    </div>\n  );\n};\n\nexport default Editor;\n","import \"../css/UserManual.css\";\n\nconst UserManual = () => {\n  return (\n    <div>\n      <h2>User Manual</h2>\n      <p>A BF program has 8 different instructions</p>\n      <table className=\"manual-table\">\n        <tr>\n          <th>Instruction</th>\n          <th>Description</th>\n        </tr>\n        <tr>\n          <td>&gt;</td>\n          <td>Move the data pointer to the right</td>\n        </tr>\n        <tr>\n          <td>&lt;</td>\n          <td>Move the data pointer to the left</td>\n        </tr>\n        <tr>\n          <td>+</td>\n          <td>Increment the current memory cell</td>\n        </tr>\n        <tr>\n          <td>-</td>\n          <td>Decrement the current memory cell</td>\n        </tr>\n        <tr>\n          <td>,</td>\n          <td>Take one input from the stdin</td>\n        </tr>\n        <tr>\n          <td>.</td>\n          <td>Print the current memory (decoded as ASCII)</td>\n        </tr>\n        <tr>\n          <td>[</td>\n          <td>\n            Do nothing when the current memory cell is 0, otherwise jump to corresponding{\" \"}\n            <code>]</code>\n          </td>\n        </tr>\n        <tr>\n          <td>]</td>\n          <td>\n            Do nothing when the current memory cell is 0, otherwise jump to corresponding{\" \"}\n            <code>[</code>\n          </td>\n        </tr>\n      </table>\n      <p>\n        Enter your program in the <span className=\"bordered-text\">Editor</span>. If it is nonempty,\n        you should be able to click on <span className=\"bordered-text\">Run</span> to run it.\n      </p>\n      <p>\n        You can also step through the program one cycle by one cycle after pressing the{\" \"}\n        <span className=\"bordered-text\">Start</span> button.\n      </p>\n      <p>\n        The <span className=\"bordered-text\">Last read</span> section indicates what the program has\n        just read from the user input.\n      </p>\n      <p>\n        To add an breakpoint, just click on the instruction to pause at in the parsed program block.\n      </p>\n    </div>\n  );\n};\n\nexport default UserManual;\n","import \"../css/Memory.css\";\n\nimport { ProgramState } from \"../core/Interpreter\";\n\nexport type MemoryProps = {\n  programState: ProgramState;\n  memoryLower: number;\n  memoryUpper: number;\n};\n\ntype MemoryBlockProps = {\n  index: number;\n  value: number;\n  highlighted: boolean;\n};\n\nconst MemoryBlock = ({ index, value, highlighted }: MemoryBlockProps) => {\n  return (\n    <div className={`memory-block${highlighted ? \" memory-block-highlighted\" : \"\"}`}>\n      <div>{index}</div>\n      <div>\n        {value}|{value.toString(16)}|{JSON.stringify(String.fromCharCode(value)).slice(1, -1)}\n      </div>\n    </div>\n  );\n};\n\nconst Memory = ({ programState, memoryLower, memoryUpper }: MemoryProps) => {\n  return (\n    <div className=\"memory-field\">\n      {programState.memory.slice(memoryLower, memoryUpper).map((value, index) => {\n        const memIndex = index + memoryLower;\n        return (\n          <MemoryBlock\n            index={memIndex}\n            value={value}\n            highlighted={programState.dataPointer === memIndex}\n            key={memIndex}\n          ></MemoryBlock>\n        );\n      })}\n      <p className=\"memory-size\">Showing {memoryUpper - memoryLower} of {programState.memory.size()} memory blocks.</p>\n    </div>\n  );\n};\n\nexport default Memory;\n","import { useMemo } from \"react\";\n\nimport { BrainfuckAction } from \"../hooks/useBrainfuck\";\n\nimport \"../css/Visualization.css\";\n\nimport { isStarted, ProgramState } from \"../core/Interpreter\";\nimport Memory from \"./Memory\";\n\nexport type VisualizationProps = {\n  programState: ProgramState;\n  dispatch: (action: BrainfuckAction) => void;\n  memoryDisplayCount: number;\n};\n\nconst Visualization = ({ programState, dispatch, memoryDisplayCount }: VisualizationProps) => {\n  const memoryLower = Math.max(0, programState.dataPointer - Math.floor(memoryDisplayCount / 2));\n  const memoryUpper = Math.min(memoryLower + memoryDisplayCount, programState.memory.size());\n  const isCurrentPc = (pc: number) =>\n    (!programState.blocked &&\n      (pc === programState.programCounter - 1 ||\n        (pc === 0 && programState.programCounter === 0))) ||\n    (programState.blocked && pc === programState.programCounter);\n  const breakpoints = useMemo(() => {\n    let currentBreakpointIndex = 0;\n    return programState.program.map((_, index) => {\n      if (index === programState.breakpoints[currentBreakpointIndex]) {\n        currentBreakpointIndex++;\n        return true;\n      }\n      return false;\n    });\n  }, [programState.program, programState.breakpoints]);\n\n  return (\n    <div>\n      <h2>Visualization</h2>\n      <div className=\"visualization\">\n        <div className=\"program-field\">\n          {programState.program.map((instruction, index) => (\n            <span\n              key={index}\n              className={(isStarted(programState) && isCurrentPc(index)\n                ? \"highlighted\"\n                : \"\"\n              ).concat(breakpoints[index] ? \" breakpoint\" : \"\")}\n              onClick={() => dispatch({ type: \"breakpoint\", data: index })}\n            >\n              {instruction}\n            </span>\n          ))}\n          <p>parsed program</p>\n        </div>\n        <div>\n          <p>\n            program counter: {programState.programCounter}\n            {programState.blocked ? \" (waiting for input)\" : \"\"}\n          </p>\n          <p>data pointer: {programState.dataPointer}</p>\n          <p>current data: {programState.memory.query(programState.dataPointer)}</p>\n        </div>\n      </div>\n      <p>Memory Cells</p>\n      <Memory programState={programState} memoryLower={memoryLower} memoryUpper={memoryUpper} />\n    </div>\n  );\n};\n\nexport default Visualization;\n","import { useEffect, useState } from \"react\";\n\nimport { useBrainfuck } from \"../hooks/useBrainfuck\";\n\nimport \"../css/App.css\";\n\nimport Console from \"./Console\";\nimport ControlPanel from \"./ControlPanel\";\nimport Editor from \"./Editor\";\nimport UserManual from \"./UserManual\";\nimport Visualization from \"./Visualization\";\n\nconst [xlg, lg, md, sm, xs] = [2560, 1920, 1463, 1024, 768];\nconst getMemoryDisplayCount = (width: number) => (width >= xlg) ? 64 : (width >= lg) ? 42 : (width >= md) ? 35 : (width >= sm) ? 24 : (width >= xs) ? 15 : 12;\n\nfunction App() {\n  const [code, setCode] = useState(\"\");\n  const [brainfuck, dispatch] = useBrainfuck(code);\n  const [editorEnabled] = useState(true);\n  const [memoryDisplayCount, setMemoryDisplayCount] = useState(getMemoryDisplayCount(window.innerWidth));\n\n  useEffect(() => {\n    function handleResize() {\n      setMemoryDisplayCount(getMemoryDisplayCount(window.innerWidth));\n    }\n\n    window.addEventListener('resize', handleResize);\n    return () => window.removeEventListener('resize', handleResize);\n  }, []);\n\n  useEffect(() => {\n    dispatch({ type: \"load\", data: code });\n    dispatch({ type: \"reset\" });\n  }, [code, dispatch]);\n\n  return (\n    <div className=\"App\">\n    <h1 id=\"center\">react-brainfucked</h1>\n      <main className=\"App-main\">\n        <div>\n        <Editor code={code} setCode={setCode} enabled={editorEnabled} />\n        <Visualization programState={brainfuck} dispatch={dispatch} memoryDisplayCount={memoryDisplayCount} />\n        </div>\n        <div>\n        <ControlPanel programState={brainfuck} setCode={setCode} dispatch={dispatch} />\n        <Console programState={brainfuck} dispatch={dispatch} />\n        <UserManual />\n        </div>\n      </main>\n    </div>\n  );\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\n\nimport App from \"./components/App\";\n\nimport \"./css/index.css\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}